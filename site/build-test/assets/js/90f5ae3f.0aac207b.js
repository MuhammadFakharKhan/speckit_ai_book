"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[9730],{3023(n,i,e){e.d(i,{R:()=>t,x:()=>s});var a=e(3696);const r={},o=a.createContext(r);function t(n){const i=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),a.createElement(o.Provider,{value:i},n.children)}},4246(n,i,e){e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=e(2540),r=e(3023);const o={title:"Domain Randomization",description:"Implementing domain randomization techniques in Isaac Sim to improve synthetic-to-real transfer for humanoid robotics",sidebar_position:5,tags:["domain-randomization","synthetic-data","transfer-learning","isaac-sim"]},t="Domain Randomization",s={id:"isaac-sim/domain-randomization",title:"Domain Randomization",description:"Implementing domain randomization techniques in Isaac Sim to improve synthetic-to-real transfer for humanoid robotics",source:"@site/docs/isaac-sim/domain-randomization.md",sourceDirName:"isaac-sim",slug:"/isaac-sim/domain-randomization",permalink:"/docs/isaac-sim/domain-randomization",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-sim/domain-randomization.md",tags:[{label:"domain-randomization",permalink:"/docs/tags/domain-randomization"},{label:"synthetic-data",permalink:"/docs/tags/synthetic-data"},{label:"transfer-learning",permalink:"/docs/tags/transfer-learning"},{label:"isaac-sim",permalink:"/docs/tags/isaac-sim"}],version:"current",sidebarPosition:5,frontMatter:{title:"Domain Randomization",description:"Implementing domain randomization techniques in Isaac Sim to improve synthetic-to-real transfer for humanoid robotics",sidebar_position:5,tags:["domain-randomization","synthetic-data","transfer-learning","isaac-sim"]},sidebar:"tutorialSidebar",previous:{title:"Synthetic Dataset Creation Workflows",permalink:"/docs/isaac-sim/synthetic-dataset-workflows"},next:{title:"Isaac ROS Perception",permalink:"/docs/isaac-ros/"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"The Domain Randomization Approach",id:"the-domain-randomization-approach",level:2},{value:"Visual Domain Randomization",id:"visual-domain-randomization",level:2},{value:"Material Randomization",id:"material-randomization",level:3},{value:"Lighting Randomization",id:"lighting-randomization",level:3},{value:"Camera Parameter Randomization",id:"camera-parameter-randomization",level:3},{value:"Physical Domain Randomization",id:"physical-domain-randomization",level:2},{value:"Dynamics Randomization",id:"dynamics-randomization",level:3},{value:"Environmental Randomization",id:"environmental-randomization",level:3},{value:"Implementation in Isaac Sim",id:"implementation-in-isaac-sim",level:2},{value:"Setting Up Domain Randomization",id:"setting-up-domain-randomization",level:3},{value:"Randomization Schedules",id:"randomization-schedules",level:3},{value:"Validation and Monitoring",id:"validation-and-monitoring",level:2},{value:"Transfer Performance Metrics",id:"transfer-performance-metrics",level:3},{value:"Randomization Effectiveness",id:"randomization-effectiveness",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Randomization Strategy",id:"randomization-strategy",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Challenges and Solutions",id:"challenges-and-solutions",level:2},{value:"Over-randomization",id:"over-randomization",level:3},{value:"Training Instability",id:"training-instability",level:3},{value:"Computational Overhead",id:"computational-overhead",level:3},{value:"Integration with Training Pipelines",id:"integration-with-training-pipelines",level:2}];function c(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h1,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,a.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(i.p,{children:"Domain randomization is a technique used to improve the transfer of models trained on synthetic data to real-world applications. By randomizing various aspects of the simulation environment, we can create models that are robust to variations in real-world conditions. This is particularly important for humanoid robotics applications where environmental conditions can vary significantly."}),"\n",(0,a.jsx)(i.h2,{id:"the-domain-randomization-approach",children:"The Domain Randomization Approach"}),"\n",(0,a.jsx)(i.p,{children:"Domain randomization works by introducing controlled randomness to various aspects of the simulation:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Visual appearance"}),": Colors, textures, lighting"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Physical properties"}),": Friction, mass, dynamics"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Scene composition"}),": Object positions, layouts"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Sensor parameters"}),": Noise, calibration variations"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"The goal is to make the model invariant to these variations, enabling better real-world performance."}),"\n",(0,a.jsx)(i.h2,{id:"visual-domain-randomization",children:"Visual Domain Randomization"}),"\n",(0,a.jsx)(i.h3,{id:"material-randomization",children:"Material Randomization"}),"\n",(0,a.jsx)(i.p,{children:"Randomizing material properties helps models generalize across different real-world materials:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Surface textures"}),": Apply random textures or procedural patterns"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Color variations"}),": Randomize colors within realistic ranges"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Reflectance properties"}),": Vary specular and diffuse properties"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Transparency"}),": Add random transparency effects where appropriate"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"lighting-randomization",children:"Lighting Randomization"}),"\n",(0,a.jsx)(i.p,{children:"Lighting conditions vary significantly in real-world environments:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Light positions"}),": Randomize the position of light sources"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Light intensities"}),": Vary light brightness within reasonable ranges"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Light colors"}),": Change light color temperature and tint"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Shadow properties"}),": Modify shadow sharpness and intensity"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"camera-parameter-randomization",children:"Camera Parameter Randomization"}),"\n",(0,a.jsx)(i.p,{children:"Randomizing camera parameters helps handle variations in real sensors:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Focus effects"}),": Add depth of field and motion blur"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Noise patterns"}),": Apply realistic sensor noise"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Distortion"}),": Include lens distortion effects"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Exposure"}),": Vary exposure settings"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"physical-domain-randomization",children:"Physical Domain Randomization"}),"\n",(0,a.jsx)(i.h3,{id:"dynamics-randomization",children:"Dynamics Randomization"}),"\n",(0,a.jsx)(i.p,{children:"Randomizing physical properties helps models adapt to different real-world conditions:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Friction coefficients"}),": Vary surface friction parameters"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Mass properties"}),": Randomize object weights and inertias"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Joint dynamics"}),": Adjust robot joint friction and damping"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Collision properties"}),": Modify restitution and friction parameters"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"environmental-randomization",children:"Environmental Randomization"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Terrain variations"}),": Randomize ground surface properties"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Obstacle placement"}),": Vary positions and types of obstacles"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Dynamic elements"}),": Add moving or changing environmental elements"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"implementation-in-isaac-sim",children:"Implementation in Isaac Sim"}),"\n",(0,a.jsx)(i.h3,{id:"setting-up-domain-randomization",children:"Setting Up Domain Randomization"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'# Example domain randomization setup\nfrom omni.isaac.core.utils.prims import get_prim_at_path\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nimport numpy as np\n\nclass DomainRandomizer:\n    def __init__(self):\n        self.randomization_params = {\n            "light_min_intensity": 100,\n            "light_max_intensity": 500,\n            "material_min_roughness": 0.1,\n            "material_max_roughness": 0.9,\n            "camera_min_noise": 0.01,\n            "camera_max_noise": 0.05\n        }\n\n    def randomize_lighting(self):\n        # Randomize all lights in the scene\n        lights = self.get_all_lights()\n        for light in lights:\n            intensity = np.random.uniform(\n                self.randomization_params["light_min_intensity"],\n                self.randomization_params["light_max_intensity"]\n            )\n            light.intensity = intensity\n\n    def randomize_materials(self):\n        # Randomize materials in the scene\n        materials = self.get_all_materials()\n        for material in materials:\n            roughness = np.random.uniform(\n                self.randomization_params["material_min_roughness"],\n                self.randomization_params["material_max_roughness"]\n            )\n            material.roughness = roughness\n'})}),"\n",(0,a.jsx)(i.h3,{id:"randomization-schedules",children:"Randomization Schedules"}),"\n",(0,a.jsx)(i.p,{children:"Consider using progressive randomization:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Start with low variation"}),": Begin training with minimal randomization"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Gradually increase"}),": Increase randomization as training progresses"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Adaptive randomization"}),": Adjust based on model performance"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"validation-and-monitoring",children:"Validation and Monitoring"}),"\n",(0,a.jsx)(i.h3,{id:"transfer-performance-metrics",children:"Transfer Performance Metrics"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Real-world accuracy"}),": Measure performance on real-world validation sets"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Synthetic accuracy"}),": Monitor performance on synthetic validation data"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Domain gap"}),": Track the difference between synthetic and real performance"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"randomization-effectiveness",children:"Randomization Effectiveness"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Gradient analysis"}),": Monitor gradients to ensure randomization isn't too extreme"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Feature visualization"}),": Examine learned features for robustness"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Ablation studies"}),": Test the impact of different randomization components"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(i.h3,{id:"randomization-strategy",children:"Randomization Strategy"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Start conservatively"}),": Begin with small randomization ranges"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Focus on important factors"}),": Prioritize randomization of domain-relevant factors"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Monitor training stability"}),": Ensure randomization doesn't destabilize training"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Validate with real data"}),": Always validate transfer performance with real-world data"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Computational cost"}),": Balance randomization complexity with simulation speed"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Memory usage"}),": Consider the impact on GPU memory for rendering"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Simulation stability"}),": Ensure randomized physics parameters maintain stability"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"challenges-and-solutions",children:"Challenges and Solutions"}),"\n",(0,a.jsx)(i.h3,{id:"over-randomization",children:"Over-randomization"}),"\n",(0,a.jsx)(i.p,{children:"Problem: Excessive randomization can make the synthetic domain too different from reality.\nSolution: Use realistic bounds and validate with real-world performance metrics."}),"\n",(0,a.jsx)(i.h3,{id:"training-instability",children:"Training Instability"}),"\n",(0,a.jsx)(i.p,{children:"Problem: High variation can destabilize training.\nSolution: Use progressive randomization or curriculum learning approaches."}),"\n",(0,a.jsx)(i.h3,{id:"computational-overhead",children:"Computational Overhead"}),"\n",(0,a.jsx)(i.p,{children:"Problem: Complex randomization can slow down simulation.\nSolution: Optimize randomization for performance-critical aspects only."}),"\n",(0,a.jsx)(i.h2,{id:"integration-with-training-pipelines",children:"Integration with Training Pipelines"}),"\n",(0,a.jsx)(i.p,{children:"Domain randomization should be integrated into your overall training workflow:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Online randomization"}),": Randomize during training for maximum variation"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Offline randomization"}),": Pre-generate diverse datasets with randomization"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Hybrid approaches"}),": Combine synthetic and real data with appropriate weighting"]}),"\n"]})]})}function m(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,a.jsx)(i,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}}}]);