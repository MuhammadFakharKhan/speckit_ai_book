"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[5527],{2265(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=i(2540),t=i(3023);const s={title:"Path Planning for Bipedal Robots",description:"Path planning algorithms adapted for humanoid robots using Nav2, considering balance and step dynamics",sidebar_position:2,tags:["path-planning","navigation","nav2","humanoid","bipedal"]},o="Path Planning for Bipedal Robots",r={id:"nav2-humanoid/path-planning",title:"Path Planning for Bipedal Robots",description:"Path planning algorithms adapted for humanoid robots using Nav2, considering balance and step dynamics",source:"@site/docs/nav2-humanoid/path-planning.md",sourceDirName:"nav2-humanoid",slug:"/nav2-humanoid/path-planning",permalink:"/docs/nav2-humanoid/path-planning",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nav2-humanoid/path-planning.md",tags:[{label:"path-planning",permalink:"/docs/tags/path-planning"},{label:"navigation",permalink:"/docs/tags/navigation"},{label:"nav2",permalink:"/docs/tags/nav-2"},{label:"humanoid",permalink:"/docs/tags/humanoid"},{label:"bipedal",permalink:"/docs/tags/bipedal"}],version:"current",sidebarPosition:2,frontMatter:{title:"Path Planning for Bipedal Robots",description:"Path planning algorithms adapted for humanoid robots using Nav2, considering balance and step dynamics",sidebar_position:2,tags:["path-planning","navigation","nav2","humanoid","bipedal"]},sidebar:"tutorialSidebar",previous:{title:"Nav2 for Humanoid Navigation",permalink:"/docs/nav2-humanoid/"},next:{title:"Localization for Humanoid Robots",permalink:"/docs/nav2-humanoid/localization"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Humanoid-Specific Path Planning Challenges",id:"humanoid-specific-path-planning-challenges",level:2},{value:"Balance Considerations",id:"balance-considerations",level:3},{value:"Step Dynamics",id:"step-dynamics",level:3},{value:"3D Navigation Requirements",id:"3d-navigation-requirements",level:3},{value:"Nav2 Adaptation for Humanoid Robots",id:"nav2-adaptation-for-humanoid-robots",level:2},{value:"Costmap Modifications",id:"costmap-modifications",level:3},{value:"Global Planner Adaptations",id:"global-planner-adaptations",level:3},{value:"Local Planner Adaptations",id:"local-planner-adaptations",level:3},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Custom Costmap Layer for Humanoid Navigation",id:"custom-costmap-layer-for-humanoid-navigation",level:3},{value:"Humanoid-Aware Global Planner",id:"humanoid-aware-global-planner",level:3},{value:"Configuration for Humanoid Nav2",id:"configuration-for-humanoid-nav2",level:3},{value:"Humanoid Navigation Behaviors",id:"humanoid-navigation-behaviors",level:2},{value:"Step-by-Step Navigation",id:"step-by-step-navigation",level:3},{value:"Z-Axis Navigation",id:"z-axis-navigation",level:3},{value:"Balance-Aware Planning",id:"balance-aware-planning",level:3},{value:"Integration with Humanoid Locomotion",id:"integration-with-humanoid-locomotion",level:2},{value:"Gait Pattern Integration",id:"gait-pattern-integration",level:3},{value:"Balance Controller Integration",id:"balance-controller-integration",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Computational Requirements",id:"computational-requirements",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging Strategies",id:"debugging-strategies",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Development Approach",id:"development-approach",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"path-planning-for-bipedal-robots",children:"Path Planning for Bipedal Robots"}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Path planning for humanoid robots presents unique challenges compared to wheeled or tracked robots. Bipedal locomotion requires consideration of balance, step dynamics, and the three-dimensional nature of human-like movement. This module covers how to adapt Nav2's path planning capabilities for humanoid robots."}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-specific-path-planning-challenges",children:"Humanoid-Specific Path Planning Challenges"}),"\n",(0,a.jsx)(e.h3,{id:"balance-considerations",children:"Balance Considerations"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots must maintain balance during navigation:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Maintain ZMP within support polygon"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Center of Mass (CoM)"}),": Keep CoM within stable region"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic balance"}),": Account for motion-induced balance changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step timing"}),": Coordinate steps with balance requirements"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"step-dynamics",children:"Step Dynamics"}),"\n",(0,a.jsx)(e.p,{children:"Bipedal locomotion involves discrete step planning:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step placement"}),": Plan individual step locations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step timing"}),": Coordinate step execution with timing constraints"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Foot placement"}),": Ensure stable foot placement locations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Swing trajectory"}),": Plan smooth foot swing motions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"3d-navigation-requirements",children:"3D Navigation Requirements"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid navigation occurs in three dimensions:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Z-axis movement"}),": Navigate changes in elevation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stair navigation"}),": Handle stairs and step obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Ramp navigation"}),": Navigate inclined surfaces"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Obstacle clearance"}),": Plan paths with adequate overhead clearance"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"nav2-adaptation-for-humanoid-robots",children:"Nav2 Adaptation for Humanoid Robots"}),"\n",(0,a.jsx)(e.h3,{id:"costmap-modifications",children:"Costmap Modifications"}),"\n",(0,a.jsx)(e.p,{children:"Adapt costmaps for humanoid-specific requirements:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"3D costmaps"}),": Consider height and elevation in cost computation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step height constraints"}),": Account for maximum step height"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Surface stability"}),": Evaluate surface stability for bipedal locomotion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Clearance requirements"}),": Ensure adequate headroom and space"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"global-planner-adaptations",children:"Global Planner Adaptations"}),"\n",(0,a.jsx)(e.p,{children:"Modify global planning for humanoid robots:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"3D path planning"}),": Plan paths in 3D space considering elevation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step sequence planning"}),": Generate step-by-step navigation plans"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance-aware planning"}),": Consider balance requirements in path selection"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic constraints"}),": Account for bipedal locomotion dynamics"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"local-planner-adaptations",children:"Local Planner Adaptations"}),"\n",(0,a.jsx)(e.p,{children:"Adapt local planning for humanoid robots:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step-by-step execution"}),": Execute navigation in discrete steps"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance recovery"}),": Implement balance recovery behaviors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Handle moving obstacles in real-time"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Footstep planning"}),": Plan footstep locations during navigation"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,a.jsx)(e.h3,{id:"custom-costmap-layer-for-humanoid-navigation",children:"Custom Costmap Layer for Humanoid Navigation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Example custom costmap layer for humanoid robots\nimport numpy as np\nfrom nav2_costmap_2d.layers import CostmapLayer\nfrom nav2_costmap_2d import Costmap2D\n\nclass HumanoidCostmapLayer(CostmapLayer):\n    def __init__(self, name, costmap, nh):\n        super().__init__()\n        self.layer_name = name\n        self.costmap = costmap\n        self.nh = nh\n\n        # Humanoid-specific parameters\n        self.max_step_height = self.nh.get_parameter('max_step_height', 0.2)  # meters\n        self.robot_height = self.nh.get_parameter('robot_height', 1.5)       # meters\n        self.min_headroom = self.nh.get_parameter('min_headroom', 0.5)       # meters\n\n    def updateBounds(self, robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y):\n        # Update bounds considering humanoid constraints\n        self.updateBoundsFromArea(min_x, min_y, max_x, max_y)\n\n        # Consider elevation changes for step height constraints\n        self.updateElevationConstraints(robot_x, robot_y, min_x, min_y, max_x, max_y)\n\n    def updateElevationConstraints(self, robot_x, robot_y, min_x, min_y, max_x, max_y):\n        # Apply step height constraints to costmap\n        for x in range(int(min_x), int(max_x)):\n            for y in range(int(min_y), int(max_y)):\n                world_x, world_y = self.costmap.getOriginX() + x, self.costmap.getOriginY() + y\n                elevation_diff = self.getElevationDifference(world_x, world_y)\n\n                if abs(elevation_diff) > self.max_step_height:\n                    # Mark as lethal obstacle if elevation change is too large\n                    self.setCost(x, y, 254)  # LETHAL_OBSTACLE\n\n    def updateCosts(self, master_grid, min_i, min_j, max_i, max_j):\n        # Apply humanoid-specific costs to master grid\n        for i in range(min_i, max_i):\n            for j in range(min_j, max_j):\n                cost = master_grid.getCost(i, j)\n                if cost >= 0 and cost < 253:  # Not unknown or lethal\n                    # Apply additional humanoid-specific costs\n                    humanoid_cost = self.calculateHumanoidCost(i, j)\n                    final_cost = self.combineCosts(cost, humanoid_cost)\n                    master_grid.setCost(i, j, final_cost)\n\n    def calculateHumanoidCost(self, i, j):\n        # Calculate humanoid-specific cost based on terrain stability, etc.\n        # Implementation depends on specific humanoid robot requirements\n        return 0\n"})}),"\n",(0,a.jsx)(e.h3,{id:"humanoid-aware-global-planner",children:"Humanoid-Aware Global Planner"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Example humanoid-aware global planner\nfrom nav2_navfn_planner import NavfnPlanner\nimport numpy as np\n\nclass HumanoidGlobalPlanner(NavfnPlanner):\n    def __init__(self):\n        super().__init__()\n        self.max_step_height = 0.2  # meters\n        self.balance_margin = 0.1   # meters\n\n    def createPlan(self, start, goal):\n        # Create plan considering humanoid constraints\n        raw_plan = super().createPlan(start, goal)\n\n        if not raw_plan:\n            return []\n\n        # Process raw plan for humanoid execution\n        humanoid_plan = self.adaptPlanForHumanoid(raw_plan)\n\n        return humanoid_plan\n\n    def adaptPlanForHumanoid(self, raw_plan):\n        # Adapt the plan for humanoid-specific requirements\n        humanoid_plan = []\n\n        for i in range(len(raw_plan) - 1):\n            current_pose = raw_plan[i]\n            next_pose = raw_plan[i + 1]\n\n            # Check if the transition is feasible for humanoid robot\n            if self.isTransitionFeasible(current_pose, next_pose):\n                # Add intermediate steps if needed for balance\n                steps = self.generateStepSequence(current_pose, next_pose)\n                humanoid_plan.extend(steps)\n            else:\n                # Find alternative path around obstacle\n                continue\n\n        return humanoid_plan\n\n    def isTransitionFeasible(self, pose1, pose2):\n        # Check if transition is feasible considering step height and balance\n        distance = self.calculateDistance(pose1, pose2)\n        elevation_diff = abs(pose2.position.z - pose1.position.z)\n\n        # Check if elevation change is within step height capability\n        if elevation_diff > self.max_step_height:\n            return False\n\n        # Check if path is within balance constraints\n        if distance > self.balance_margin * 2:  # Simplified check\n            return False\n\n        return True\n\n    def generateStepSequence(self, start_pose, end_pose):\n        # Generate sequence of steps between poses\n        steps = []\n        distance = self.calculateDistance(start_pose, end_pose)\n\n        # Calculate number of steps needed\n        step_size = 0.3  # Average step size for humanoid\n        num_steps = int(distance / step_size) + 1\n\n        for i in range(num_steps):\n            ratio = i / num_steps\n            step_pose = self.interpolatePose(start_pose, end_pose, ratio)\n            steps.append(step_pose)\n\n        return steps\n"})}),"\n",(0,a.jsx)(e.h3,{id:"configuration-for-humanoid-nav2",children:"Configuration for Humanoid Nav2"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'# Example Nav2 configuration for humanoid robot\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Humanoid-specific parameters\n    step_execution_timeout: 5.0\n    balance_check_frequency: 10.0\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: False\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific controller\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 50\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.2\n      vy_std: 0.1\n      wz_std: 0.4\n      vx_max: 0.5\n      vx_min: -0.1\n      vy_max: 0.3\n      wz_max: 0.5\n      # Humanoid-specific constraints\n      step_size_max: 0.4\n      balance_margin: 0.15\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: False\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05\n      # Humanoid-specific parameters\n      max_step_height: 0.2\n      robot_height: 1.5\n      min_headroom: 0.5\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: False\n      robot_radius: 0.3\n      # Humanoid-specific parameters\n      max_step_height: 0.2\n      robot_height: 1.5\n      min_headroom: 0.5\n'})}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-navigation-behaviors",children:"Humanoid Navigation Behaviors"}),"\n",(0,a.jsx)(e.h3,{id:"step-by-step-navigation",children:"Step-by-Step Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Implement step-by-step navigation execution:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step planning"}),": Plan each individual step location"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step execution"}),": Execute steps with proper timing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance monitoring"}),": Monitor balance during step execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery behaviors"}),": Handle balance recovery when needed"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation",children:"Z-Axis Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Handle elevation changes in navigation:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stair detection"}),": Identify stairs and step obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Ramp navigation"}),": Navigate inclined surfaces appropriately"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step climbing"}),": Execute step climbing motions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Elevation planning"}),": Plan paths with elevation changes"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"balance-aware-planning",children:"Balance-Aware Planning"}),"\n",(0,a.jsx)(e.p,{children:"Consider balance in path planning:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Support polygon"}),": Maintain feet within support polygon"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic stability"}),": Account for dynamic balance during movement"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery planning"}),": Plan recovery motions when balance is challenged"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gait adaptation"}),": Adapt gait based on terrain and obstacles"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"integration-with-humanoid-locomotion",children:"Integration with Humanoid Locomotion"}),"\n",(0,a.jsx)(e.h3,{id:"gait-pattern-integration",children:"Gait Pattern Integration"}),"\n",(0,a.jsx)(e.p,{children:"Integrate path planning with gait patterns:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gait selection"}),": Choose appropriate gait for planned path"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step timing"}),": Coordinate step execution with path following"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gait adaptation"}),": Adapt gait based on terrain and obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stability margins"}),": Maintain stability during gait transitions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"balance-controller-integration",children:"Balance Controller Integration"}),"\n",(0,a.jsx)(e.p,{children:"Coordinate with balance controllers:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance feedback"}),": Use balance controller feedback in planning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stability constraints"}),": Apply stability constraints to path planning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery coordination"}),": Coordinate recovery behaviors with navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic compensation"}),": Adjust path based on balance requirements"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"computational-requirements",children:"Computational Requirements"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid navigation has specific computational needs:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time constraints"}),": Meet real-time step execution requirements"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path replanning"}),": Replan efficiently when obstacles are encountered"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance computation"}),": Compute balance requirements in real-time"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor processing"}),": Process sensor data for balance and navigation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(e.p,{children:"Manage memory for complex humanoid navigation:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path storage"}),": Store detailed path information for step execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance states"}),": Maintain balance state information"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Terrain data"}),": Store terrain information for navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery plans"}),": Pre-compute recovery plans when possible"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance failures"}),": Handle balance loss during navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step execution failures"}),": Handle failed step execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path replanning loops"}),": Avoid infinite replanning cycles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Elevation handling"}),": Handle elevation changes properly"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"debugging-strategies",children:"Debugging Strategies"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visualization"}),": Use Rviz to visualize planned paths and steps"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Logging"}),": Log balance and navigation states for debugging"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simulation"}),": Test navigation in simulation before real robot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety stops"}),": Implement safety stops for dangerous situations"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"development-approach",children:"Development Approach"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simulation first"}),": Test navigation in simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Incremental complexity"}),": Start with simple navigation tasks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety considerations"}),": Always implement safety checks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validation"}),": Validate navigation performance with real robots"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter tuning"}),": Carefully tune parameters for your specific robot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Testing"}),": Test navigation in various environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Documentation"}),": Document all navigation configurations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Backup plans"}),": Implement fallback navigation strategies"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(e.p,{children:["For more detailed information about Nav2 and its customization for humanoid robots, refer to the ",(0,a.jsx)(e.a,{href:"https://navigation.ros.org/",children:"official Nav2 documentation"})," and the ",(0,a.jsx)(e.a,{href:"https://navigation.ros.org/tutorials/",children:"ROS 2 Navigation tutorials"}),"."]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},3023(n,e,i){i.d(e,{R:()=>o,x:()=>r});var a=i(3696);const t={},s=a.createContext(t);function o(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);