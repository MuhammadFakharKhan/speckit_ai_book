"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[5844],{3023(n,e,t){t.d(e,{R:()=>s,x:()=>r});var a=t(3696);const i={},o=a.createContext(i);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(o.Provider,{value:e},n.children)}},5363(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(2540),i=t(3023);const o={title:"Command Translation to ROS 2",description:"Documentation on translating parsed voice commands to ROS 2 actions and messages in VLA systems",sidebar_position:4,tags:["vla","command-translation","ros2","robot-control","action-execution"]},s="Command Translation to ROS 2",r={id:"voice-to-action/command-translation",title:"Command Translation to ROS 2",description:"Documentation on translating parsed voice commands to ROS 2 actions and messages in VLA systems",source:"@site/docs/voice-to-action/command-translation.md",sourceDirName:"voice-to-action",slug:"/voice-to-action/command-translation",permalink:"/docs/voice-to-action/command-translation",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/voice-to-action/command-translation.md",tags:[{label:"vla",permalink:"/docs/tags/vla"},{label:"command-translation",permalink:"/docs/tags/command-translation"},{label:"ros2",permalink:"/docs/tags/ros-2"},{label:"robot-control",permalink:"/docs/tags/robot-control"},{label:"action-execution",permalink:"/docs/tags/action-execution"}],version:"current",sidebarPosition:4,frontMatter:{title:"Command Translation to ROS 2",description:"Documentation on translating parsed voice commands to ROS 2 actions and messages in VLA systems",sidebar_position:4,tags:["vla","command-translation","ros2","robot-control","action-execution"]},sidebar:"tutorialSidebar",previous:{title:"Intent Parsing and Natural Language Understanding",permalink:"/docs/voice-to-action/intent-parsing"},next:{title:"Confidence Scoring and Validation in Voice Processing",permalink:"/docs/voice-to-action/confidence-scoring"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Translation Architecture",id:"translation-architecture",level:2},{value:"Processing Pipeline",id:"processing-pipeline",level:3},{value:"Core Components",id:"core-components",level:3},{value:"Intent-to-Action Mapping",id:"intent-to-action-mapping",level:2},{value:"Navigation Commands",id:"navigation-commands",level:3},{value:"Manipulation Commands",id:"manipulation-commands",level:3},{value:"Perception Commands",id:"perception-commands",level:3},{value:"Message Construction",id:"message-construction",level:2},{value:"Standard ROS 2 Message Types",id:"standard-ros-2-message-types",level:3},{value:"Action Validation",id:"action-validation",level:2},{value:"Capability Checking",id:"capability-checking",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Publisher Implementation",id:"publisher-implementation",level:3},{value:"Action Client Implementation",id:"action-client-implementation",level:3},{value:"Execution Monitoring",id:"execution-monitoring",level:2},{value:"Status Tracking",id:"status-tracking",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Command Validation Errors",id:"command-validation-errors",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Optimization Strategies",id:"optimization-strategies",level:3},{value:"Resource Management",id:"resource-management",level:3},{value:"Security and Safety",id:"security-and-safety",level:2},{value:"Safety Validation",id:"safety-validation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Command Design",id:"command-design",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Diagnostic Tools",id:"diagnostic-tools",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Advanced Features",id:"advanced-features",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"command-translation-to-ros-2",children:"Command Translation to ROS 2"}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Command translation is the critical component that converts structured intents from the intent parsing stage into executable ROS 2 actions and messages. This component bridges the gap between natural language understanding and robot control, enabling the Vision-Language-Action (VLA) system to execute voice commands through the ROS 2 ecosystem."}),"\n",(0,a.jsx)(e.h2,{id:"translation-architecture",children:"Translation Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"processing-pipeline",children:"Processing Pipeline"}),"\n",(0,a.jsx)(e.p,{children:"The command translation system follows a structured pipeline:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Parsed Intent \u2192 Action Mapping \u2192 Message Construction \u2192 ROS 2 Publication \u2192 Execution Monitoring\n"})}),"\n",(0,a.jsx)(e.p,{children:"Each stage transforms the command from a high-level intent to specific ROS 2 messages that control the robot's behavior."}),"\n",(0,a.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Intent Mapper"}),": Maps parsed intents to ROS 2 action types"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Message Constructor"}),": Builds appropriate ROS 2 messages with parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Action Validator"}),": Validates that actions are feasible given robot capabilities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Message Publisher"}),": Publishes messages to appropriate ROS 2 topics/services"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Execution Monitor"}),": Tracks action execution and reports status"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"intent-to-action-mapping",children:"Intent-to-Action Mapping"}),"\n",(0,a.jsx)(e.h3,{id:"navigation-commands",children:"Navigation Commands"}),"\n",(0,a.jsx)(e.p,{children:"Navigation commands are translated to ROS 2 Navigation actions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from geometry_msgs.msg import PoseStamped\nfrom nav_msgs.msg import Path\nfrom builtin_interfaces.msg import Duration\n\nclass NavigationCommandTranslator:\n    def __init__(self):\n        self.nav_client = None  # Navigation action client\n        self.known_locations = {}  # Predefined locations\n\n    def translate_move_to_command(self, intent_params):\n        """\n        Translate MoveTo intent to ROS 2 navigation command\n        """\n        # Look up destination in known locations\n        destination = self.known_locations.get(intent_params.destination)\n        if not destination:\n            # Try to find destination in environment map\n            destination = self.find_location_in_map(intent_params.destination)\n\n        if not destination:\n            raise ValueError(f"Unknown destination: {intent_params.destination}")\n\n        # Create ROS 2 navigation goal\n        goal = self.create_navigation_goal(destination)\n        return goal\n\n    def create_navigation_goal(self, destination):\n        """\n        Create a ROS 2 navigation goal from destination coordinates\n        """\n        goal = PoseStamped()\n        goal.header.stamp = self.get_clock().now().to_msg()\n        goal.header.frame_id = "map"\n        goal.pose.position.x = destination[\'x\']\n        goal.pose.position.y = destination[\'y\']\n        goal.pose.position.z = destination[\'z\']\n        goal.pose.orientation.w = 1.0  # Default orientation\n\n        return goal\n\n    def translate_move_direction_command(self, intent_params):\n        """\n        Translate MoveDirection intent to ROS 2 movement command\n        """\n        # Calculate target position based on current position and direction\n        current_pos = self.get_robot_position()\n        target_pos = self.calculate_target_position(\n            current_pos,\n            intent_params.direction,\n            intent_params.distance\n        )\n\n        goal = PoseStamped()\n        goal.header.stamp = self.get_clock().now().to_msg()\n        goal.header.frame_id = "map"\n        goal.pose.position.x = target_pos[\'x\']\n        goal.pose.position.y = target_pos[\'y\']\n        goal.pose.position.z = target_pos[\'z\']\n\n        return goal\n'})}),"\n",(0,a.jsx)(e.h3,{id:"manipulation-commands",children:"Manipulation Commands"}),"\n",(0,a.jsx)(e.p,{children:"Manipulation commands are translated to ROS 2 manipulation actions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from geometry_msgs.msg import Point, Pose\nfrom std_msgs.msg import String\n\nclass ManipulationCommandTranslator:\n    def __init__(self):\n        self.manipulation_client = None  # Manipulation action client\n        self.object_detector = None      # Object detection service\n\n    def translate_pick_up_command(self, intent_params):\n        \"\"\"\n        Translate PickUp intent to ROS 2 manipulation command\n        \"\"\"\n        # Find the target object\n        target_object = self.find_object_by_type_and_color(\n            intent_params.object_type,\n            intent_params.object_color\n        )\n\n        if not target_object:\n            raise ValueError(f\"Could not find object: {intent_params.object_type}\")\n\n        # Create manipulation goal for picking up\n        goal = self.create_pickup_goal(target_object)\n        return goal\n\n    def create_pickup_goal(self, object_info):\n        \"\"\"\n        Create a ROS 2 manipulation goal for picking up an object\n        \"\"\"\n        # This would involve multiple steps: approach, grasp, lift\n        goal = {\n            'action': 'pickup',\n            'object_pose': object_info['pose'],\n            'grasp_type': 'top_grasp',  # Default grasp type\n            'pre_grasp_distance': 0.1   # Distance before grasp\n        }\n\n        return goal\n\n    def translate_place_command(self, intent_params):\n        \"\"\"\n        Translate Place intent to ROS 2 manipulation command\n        \"\"\"\n        # Determine placement location\n        placement_location = self.known_locations.get(intent_params.destination)\n        if not placement_location:\n            placement_location = self.find_placement_location(intent_params.destination)\n\n        # Create manipulation goal for placing\n        goal = {\n            'action': 'place',\n            'target_pose': placement_location,\n            'release_height': 0.1\n        }\n\n        return goal\n"})}),"\n",(0,a.jsx)(e.h3,{id:"perception-commands",children:"Perception Commands"}),"\n",(0,a.jsx)(e.p,{children:"Perception commands are translated to ROS 2 perception actions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from sensor_msgs.msg import Image\nfrom vision_msgs.msg import Detection2DArray\n\nclass PerceptionCommandTranslator:\n    def __init__(self):\n        self.object_detection_client = None\n        self.scene_understanding_client = None\n\n    def translate_find_object_command(self, intent_params):\n        \"\"\"\n        Translate FindObject intent to ROS 2 perception command\n        \"\"\"\n        # Create object detection request\n        request = {\n            'object_type': intent_params.object_type,\n            'object_color': intent_params.object_color,\n            'search_area': 'current_view'  # or specific area\n        }\n\n        return request\n\n    def translate_describe_command(self, intent_params):\n        \"\"\"\n        Translate Describe intent to ROS 2 scene understanding command\n        \"\"\"\n        # Create scene description request\n        request = {\n            'description_type': 'environmental',\n            'include_objects': True,\n            'include_locations': True\n        }\n\n        return request\n"})}),"\n",(0,a.jsx)(e.h2,{id:"message-construction",children:"Message Construction"}),"\n",(0,a.jsx)(e.h3,{id:"standard-ros-2-message-types",children:"Standard ROS 2 Message Types"}),"\n",(0,a.jsx)(e.p,{children:"The system constructs various ROS 2 message types based on the command:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from geometry_msgs.msg import Twist, PoseStamped\nfrom std_msgs.msg import String, Bool\nfrom action_msgs.msg import GoalStatus\n\nclass MessageConstructor:\n    def __init__(self):\n        self.robot_capabilities = self.get_robot_capabilities()\n\n    def construct_navigation_message(self, target_pose):\n        """\n        Construct navigation message for the robot\n        """\n        if self.robot_capabilities.get(\'navigation_available\', False):\n            # Use Navigation2 for complex navigation\n            from nav2_msgs.action import NavigateToPose\n            goal = NavigateToPose.Goal()\n            goal.pose = target_pose\n            return goal\n        else:\n            # Fallback to simple movement commands\n            return self.construct_simple_navigation_message(target_pose)\n\n    def construct_simple_navigation_message(self, target_pose):\n        """\n        Construct simple movement message as fallback\n        """\n        # Calculate movement command based on target\n        movement_cmd = Twist()\n\n        # Calculate linear and angular velocities based on target position\n        # This is simplified - real implementation would be more sophisticated\n        movement_cmd.linear.x = 0.5  # Default forward speed\n        movement_cmd.angular.z = 0.2  # Default turning speed\n\n        return movement_cmd\n\n    def construct_manipulation_message(self, manipulation_goal):\n        """\n        Construct manipulation message for the robot\n        """\n        # This would depend on the specific manipulation system\n        # For a generic manipulator:\n        from control_msgs.msg import FollowJointTrajectoryGoal\n        from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\n        # Create trajectory for manipulation\n        trajectory = JointTrajectory()\n        trajectory.joint_names = self.robot_capabilities.get(\'manipulator_joints\', [])\n\n        # Add trajectory points for the manipulation sequence\n        point = JointTrajectoryPoint()\n        # Set joint positions for grasp, lift, etc.\n        trajectory.points.append(point)\n\n        return trajectory\n\n    def construct_perception_message(self, perception_request):\n        """\n        Construct perception message for the robot\n        """\n        # Create request for object detection service\n        from vision_msgs.srv import DetectObject\n        request = DetectObject.Request()\n        request.object_type = perception_request[\'object_type\']\n        request.object_color = perception_request[\'object_color\']\n\n        return request\n'})}),"\n",(0,a.jsx)(e.h2,{id:"action-validation",children:"Action Validation"}),"\n",(0,a.jsx)(e.h3,{id:"capability-checking",children:"Capability Checking"}),"\n",(0,a.jsx)(e.p,{children:"Before executing commands, the system validates that the robot can perform the requested actions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ActionValidator:\n    def __init__(self):\n        self.robot_capabilities = self.load_robot_capabilities()\n\n    def validate_navigation_action(self, destination):\n        \"\"\"\n        Validate that navigation to destination is possible\n        \"\"\"\n        # Check if destination is within robot's operational area\n        if not self.is_within_operational_area(destination):\n            return False, f\"Destination {destination} is outside operational area\"\n\n        # Check if path to destination is clear\n        path_clear = self.check_path_clearance(destination)\n        if not path_clear:\n            return False, f\"Path to {destination} is blocked\"\n\n        return True, \"Navigation is feasible\"\n\n    def validate_manipulation_action(self, object_info):\n        \"\"\"\n        Validate that manipulation of object is possible\n        \"\"\"\n        # Check if object is within manipulator reach\n        if not self.is_within_reach(object_info['pose']):\n            return False, \"Object is outside manipulator reach\"\n\n        # Check if robot has manipulation capabilities\n        if not self.robot_capabilities.get('manipulation_available', False):\n            return False, \"Robot does not have manipulation capabilities\"\n\n        # Check if object is graspable\n        if not self.is_graspable(object_info):\n            return False, f\"Object {object_info['type']} is not graspable\"\n\n        return True, \"Manipulation is feasible\"\n\n    def validate_perception_action(self, request):\n        \"\"\"\n        Validate that perception request can be fulfilled\n        \"\"\"\n        # Check if robot has required sensors\n        required_sensors = self.get_required_sensors(request)\n        available_sensors = self.robot_capabilities.get('sensors', [])\n\n        for sensor in required_sensors:\n            if sensor not in available_sensors:\n                return False, f\"Missing required sensor: {sensor}\"\n\n        return True, \"Perception request is feasible\"\n\n    def load_robot_capabilities(self):\n        \"\"\"\n        Load robot capabilities from configuration\n        \"\"\"\n        # This would typically come from robot description or service\n        return {\n            'navigation_available': True,\n            'manipulation_available': True,\n            'sensors': ['camera', 'lidar', 'imu'],\n            'manipulator_joints': ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6'],\n            'max_velocity': 1.0,\n            'operational_area': {'x_min': -10, 'x_max': 10, 'y_min': -10, 'y_max': 10}\n        }\n"})}),"\n",(0,a.jsx)(e.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,a.jsx)(e.h3,{id:"publisher-implementation",children:"Publisher Implementation"}),"\n",(0,a.jsx)(e.p,{children:"The system publishes commands to appropriate ROS 2 topics:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import String\n\nclass CommandPublisher(Node):\n    def __init__(self):\n        super().__init__(\'command_publisher\')\n\n        # Publishers for different command types\n        self.nav_publisher = self.create_publisher(\n            PoseStamped,\n            \'/goal_pose\',\n            10\n        )\n\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            \'/cmd_vel\',\n            10\n        )\n\n        self.manipulation_publisher = self.create_publisher(\n            String,  # This would be a custom manipulation message\n            \'/manipulation_command\',\n            10\n        )\n\n        self.perception_publisher = self.create_publisher(\n            String,  # This would be a custom perception request\n            \'/perception_request\',\n            10\n        )\n\n    def publish_navigation_command(self, goal_pose):\n        """\n        Publish navigation command to ROS 2\n        """\n        self.nav_publisher.publish(goal_pose)\n        self.get_logger().info(f\'Published navigation goal: {goal_pose}\')\n\n    def publish_movement_command(self, twist_cmd):\n        """\n        Publish movement command to ROS 2\n        """\n        self.cmd_vel_publisher.publish(twist_cmd)\n        self.get_logger().info(f\'Published movement command: {twist_cmd}\')\n\n    def publish_manipulation_command(self, manipulation_cmd):\n        """\n        Publish manipulation command to ROS 2\n        """\n        self.manipulation_publisher.publish(manipulation_cmd)\n        self.get_logger().info(f\'Published manipulation command: {manipulation_cmd}\')\n\n    def publish_perception_request(self, perception_request):\n        """\n        Publish perception request to ROS 2\n        """\n        self.perception_publisher.publish(perception_request)\n        self.get_logger().info(f\'Published perception request: {perception_request}\')\n'})}),"\n",(0,a.jsx)(e.h3,{id:"action-client-implementation",children:"Action Client Implementation"}),"\n",(0,a.jsx)(e.p,{children:"For more complex commands, the system uses ROS 2 action clients:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\n\nclass ActionCommander(Node):\n    def __init__(self):\n        super().__init__(\'action_commander\')\n\n        # Action clients for complex tasks\n        self.nav_client = ActionClient(\n            self,\n            NavigateToPose,\n            \'navigate_to_pose\'\n        )\n\n        self.manipulation_client = ActionClient(\n            self,\n            FollowJointTrajectory,\n            \'manipulator_controller/follow_joint_trajectory\'\n        )\n\n    def send_navigation_goal(self, target_pose):\n        """\n        Send navigation goal using action client\n        """\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = target_pose\n\n        # Wait for server\n        self.nav_client.wait_for_server()\n\n        # Send goal\n        future = self.nav_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.navigation_feedback_callback\n        )\n\n        future.add_done_callback(self.navigation_done_callback)\n        return future\n\n    def navigation_feedback_callback(self, feedback_msg):\n        """\n        Handle navigation feedback\n        """\n        self.get_logger().info(\n            f\'Navigation feedback: {feedback_msg.feedback.distance_remaining}m remaining\'\n        )\n\n    def navigation_done_callback(self, future):\n        """\n        Handle navigation completion\n        """\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Navigation goal rejected\')\n            return\n\n        self.get_logger().info(\'Navigation goal accepted\')\n'})}),"\n",(0,a.jsx)(e.h2,{id:"execution-monitoring",children:"Execution Monitoring"}),"\n",(0,a.jsx)(e.h3,{id:"status-tracking",children:"Status Tracking"}),"\n",(0,a.jsx)(e.p,{children:"The system monitors command execution and provides feedback:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from enum import Enum\nfrom dataclasses import dataclass\n\nclass ExecutionStatus(Enum):\n    PENDING = "pending"\n    EXECUTING = "executing"\n    COMPLETED = "completed"\n    FAILED = "failed"\n    CANCELLED = "cancelled"\n\n@dataclass\nclass ExecutionResult:\n    status: ExecutionStatus\n    success: bool\n    message: str\n    execution_time: float\n    error_details: str = None\n\nclass ExecutionMonitor:\n    def __init__(self):\n        self.active_goals = {}\n        self.command_history = []\n\n    def start_monitoring(self, command_id, goal_handle):\n        """\n        Start monitoring execution of a command\n        """\n        self.active_goals[command_id] = {\n            \'goal_handle\': goal_handle,\n            \'start_time\': self.get_current_time(),\n            \'status\': ExecutionStatus.PENDING\n        }\n\n    def check_execution_status(self, command_id):\n        """\n        Check the status of a command execution\n        """\n        if command_id not in self.active_goals:\n            return ExecutionResult(\n                status=ExecutionStatus.FAILED,\n                success=False,\n                message=f"Command {command_id} not found",\n                execution_time=0.0\n            )\n\n        goal_info = self.active_goals[command_id]\n        goal_handle = goal_info[\'goal_handle\']\n\n        # Check if goal is still active\n        if not goal_handle.is_active:\n            # Goal has finished\n            result = goal_handle.result()\n            execution_time = self.get_current_time() - goal_info[\'start_time\']\n\n            if result.success:\n                status = ExecutionStatus.COMPLETED\n                success = True\n                message = "Command completed successfully"\n            else:\n                status = ExecutionStatus.FAILED\n                success = False\n                message = f"Command failed: {result.message}"\n\n            # Remove from active goals and add to history\n            self.command_history.append({\n                \'command_id\': command_id,\n                \'status\': status,\n                \'execution_time\': execution_time,\n                \'result\': result\n            })\n            del self.active_goals[command_id]\n\n            return ExecutionResult(\n                status=status,\n                success=success,\n                message=message,\n                execution_time=execution_time\n            )\n\n        # Still executing\n        return ExecutionResult(\n            status=ExecutionStatus.EXECUTING,\n            success=False,\n            message="Command still executing",\n            execution_time=self.get_current_time() - goal_info[\'start_time\']\n        )\n\n    def cancel_command(self, command_id):\n        """\n        Cancel an executing command\n        """\n        if command_id in self.active_goals:\n            goal_handle = self.active_goals[command_id][\'goal_handle\']\n            goal_handle.cancel_goal()\n\n            self.command_history.append({\n                \'command_id\': command_id,\n                \'status\': ExecutionStatus.CANCELLED,\n                \'execution_time\': self.get_current_time() - self.active_goals[command_id][\'start_time\'],\n                \'result\': None\n            })\n            del self.active_goals[command_id]\n\n            return ExecutionResult(\n                status=ExecutionStatus.CANCELLED,\n                success=False,\n                message="Command cancelled",\n                execution_time=self.get_current_time() - self.active_goals[command_id][\'start_time\']\n            )\n'})}),"\n",(0,a.jsx)(e.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,a.jsx)(e.h3,{id:"command-validation-errors",children:"Command Validation Errors"}),"\n",(0,a.jsx)(e.p,{children:"The system handles various validation and execution errors:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class CommandErrorHandler:\n    def __init__(self):\n        self.recovery_strategies = self.load_recovery_strategies()\n\n    def handle_translation_error(self, error, intent, original_text):\n        \"\"\"\n        Handle errors during command translation\n        \"\"\"\n        error_type = type(error).__name__\n\n        if error_type == \"ValueError\":\n            # Typically means unknown location or object\n            return self.handle_unknown_reference(error, intent, original_text)\n        elif error_type == \"AttributeError\":\n            # Missing parameters or attributes\n            return self.handle_missing_parameters(error, intent, original_text)\n        else:\n            # General error\n            return self.handle_general_error(error, intent, original_text)\n\n    def handle_unknown_reference(self, error, intent, original_text):\n        \"\"\"\n        Handle errors due to unknown locations or objects\n        \"\"\"\n        # Suggest alternatives or request clarification\n        suggestion = f\"I don't know about {str(error)}. Could you specify a known location or describe the object differently?\"\n        return {\n            'success': False,\n            'error': str(error),\n            'suggestion': suggestion,\n            'requires_clarification': True\n        }\n\n    def handle_missing_parameters(self, error, intent, original_text):\n        \"\"\"\n        Handle errors due to missing command parameters\n        \"\"\"\n        # Request missing information\n        suggestion = f\"I need more information to execute this command. {str(error)}\"\n        return {\n            'success': False,\n            'error': str(error),\n            'suggestion': suggestion,\n            'requires_clarification': True\n        }\n\n    def handle_general_error(self, error, intent, original_text):\n        \"\"\"\n        Handle general translation errors\n        \"\"\"\n        suggestion = f\"I couldn't process the command '{original_text}'. Please try rephrasing.\"\n        return {\n            'success': False,\n            'error': str(error),\n            'suggestion': suggestion,\n            'requires_clarification': False\n        }\n\n    def load_recovery_strategies(self):\n        \"\"\"\n        Load predefined recovery strategies for common errors\n        \"\"\"\n        return {\n            'navigation_blocked': [\n                'Try alternative route',\n                'Clear path if possible',\n                'Use different destination'\n            ],\n            'object_not_found': [\n                'Search in different area',\n                'Verify object description',\n                'Check if object exists'\n            ],\n            'manipulation_failed': [\n                'Try different grasp approach',\n                'Check object stability',\n                'Verify manipulator availability'\n            ]\n        }\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Caching"}),": Cache frequently used location coordinates and object positions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Batching"}),": Group related commands for efficient execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Prediction"}),": Pre-calculate likely next commands based on context"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Prioritization"}),": Prioritize safety-critical commands"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"resource-management",children:"Resource Management"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ResourceManager:\n    def __init__(self):\n        self.resource_limits = {\n            'max_navigation_goals': 5,\n            'max_manipulation_attempts': 3,\n            'command_queue_size': 10\n        }\n        self.current_resources = {\n            'active_navigation_goals': 0,\n            'active_manipulation_goals': 0,\n            'queued_commands': 0\n        }\n\n    def check_resource_availability(self, command_type):\n        \"\"\"\n        Check if sufficient resources are available for command\n        \"\"\"\n        if command_type == 'navigation':\n            return (self.current_resources['active_navigation_goals'] <\n                   self.resource_limits['max_navigation_goals'])\n        elif command_type == 'manipulation':\n            return (self.current_resources['active_manipulation_goals'] <\n                   self.resource_limits['max_manipulation_attempts'])\n        else:\n            return True\n\n    def acquire_resources(self, command_type):\n        \"\"\"\n        Acquire resources for command execution\n        \"\"\"\n        if command_type == 'navigation':\n            self.current_resources['active_navigation_goals'] += 1\n        elif command_type == 'manipulation':\n            self.current_resources['active_manipulation_goals'] += 1\n\n    def release_resources(self, command_type):\n        \"\"\"\n        Release resources after command completion\n        \"\"\"\n        if command_type == 'navigation':\n            self.current_resources['active_navigation_goals'] -= 1\n        elif command_type == 'manipulation':\n            self.current_resources['active_manipulation_goals'] -= 1\n"})}),"\n",(0,a.jsx)(e.h2,{id:"security-and-safety",children:"Security and Safety"}),"\n",(0,a.jsx)(e.h3,{id:"safety-validation",children:"Safety Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class SafetyValidator:\n    def __init__(self):\n        self.safety_constraints = self.load_safety_constraints()\n\n    def validate_command_safety(self, command, context):\n        \"\"\"\n        Validate that command is safe to execute\n        \"\"\"\n        # Check navigation safety\n        if command.get('type') == 'navigation':\n            return self.validate_navigation_safety(command, context)\n\n        # Check manipulation safety\n        elif command.get('type') == 'manipulation':\n            return self.validate_manipulation_safety(command, context)\n\n        # Check other command types\n        else:\n            return self.validate_general_safety(command, context)\n\n    def validate_navigation_safety(self, command, context):\n        \"\"\"\n        Validate safety of navigation commands\n        \"\"\"\n        destination = command.get('destination')\n\n        # Check if destination is in safe area\n        if not self.is_safe_area(destination):\n            return False, f\"Destination {destination} is in unsafe area\"\n\n        # Check path for obstacles\n        path = self.calculate_path(context['current_position'], destination)\n        if self.has_unsafe_obstacles(path):\n            return False, \"Path contains unsafe obstacles\"\n\n        return True, \"Navigation is safe\"\n\n    def load_safety_constraints(self):\n        \"\"\"\n        Load safety constraints from configuration\n        \"\"\"\n        return {\n            'no_go_zones': [],\n            'maximum_speed': 1.0,\n            'minimum_distance_to_people': 1.0,\n            'safe_operational_area': {'x_min': -10, 'x_max': 10, 'y_min': -10, 'y_max': 10}\n        }\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"command-design",children:"Command Design"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Consistency"}),": Use consistent command structures across different robot types"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flexibility"}),": Allow for robot-specific adaptations while maintaining compatibility"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feedback"}),": Provide clear feedback about command status and execution results"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Graceful Degradation"}),": Handle unavailable capabilities gracefully"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Specific Error Messages"}),": Provide clear, actionable error messages"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery Options"}),": Suggest alternatives when commands fail"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Context Awareness"}),": Consider environmental context in error handling"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"User Communication"}),": Clearly communicate robot state and limitations"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Message Type Mismatches"}),": Ensure message types match ROS 2 interface definitions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Coordinate Frame Issues"}),": Verify all coordinate frames are properly defined"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Action Server Availability"}),": Check that required action servers are running"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Permission Issues"}),": Ensure proper ROS 2 permissions for command execution"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagnostic-tools",children:"Diagnostic Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"def diagnose_command_translation(parsed_intent):\n    \"\"\"\n    Diagnose potential issues with command translation\n    \"\"\"\n    diagnostics = {\n        'intent_type': parsed_intent.intent_type,\n        'parameters': parsed_intent.parameters,\n        'confidence': parsed_intent.confidence,\n        'translation_possible': True,\n        'issues': []\n    }\n\n    # Check for missing parameters\n    if parsed_intent.intent_type in ['move_to', 'fetch'] and not parsed_intent.parameters.destination:\n        diagnostics['translation_possible'] = False\n        diagnostics['issues'].append('Missing destination parameter')\n\n    # Check for robot capability match\n    # Additional checks based on intent type...\n\n    return diagnostics\n"})}),"\n",(0,a.jsx)(e.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,a.jsx)(e.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Predictive Translation"}),": Pre-translate likely commands based on context"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multi-Robot Coordination"}),": Coordinate commands across multiple robots"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Learning-Based Adaptation"}),": Adapt translation based on execution success"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Natural Language Feedback"}),": Generate natural language status updates"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"Command translation is the essential link between high-level voice commands and low-level robot control in the VLA system. By accurately converting parsed intents into appropriate ROS 2 messages, the system enables intuitive human-robot interaction while maintaining safety and reliability."}),"\n",(0,a.jsxs)(e.p,{children:["For implementation details, refer to the complete ",(0,a.jsx)(e.a,{href:"/docs/voice-to-action/",children:"Voice Command Processing"})," overview and continue with the ",(0,a.jsx)(e.a,{href:"/docs/voice-to-action/",children:"Voice-to-Action Pipeline"})," documentation."]})]})}function m(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);