"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[3951],{3023(e,n,a){a.d(n,{R:()=>r,x:()=>o});var t=a(3696);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},8948(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>_,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=a(2540),i=a(3023);const s={title:"Isaac Sim to Nav2 Integration",description:"Integration examples showing how Isaac Sim environments are used for Nav2 navigation testing and validation",sidebar_position:13,tags:["integration","isaac-sim","nav2","navigation","simulation"]},r="Isaac Sim to Nav2 Integration",o={id:"isaac-sim-to-nav2-integration",title:"Isaac Sim to Nav2 Integration",description:"Integration examples showing how Isaac Sim environments are used for Nav2 navigation testing and validation",source:"@site/docs/isaac-sim-to-nav2-integration.md",sourceDirName:".",slug:"/isaac-sim-to-nav2-integration",permalink:"/docs/isaac-sim-to-nav2-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-sim-to-nav2-integration.md",tags:[{label:"integration",permalink:"/docs/tags/integration"},{label:"isaac-sim",permalink:"/docs/tags/isaac-sim"},{label:"nav2",permalink:"/docs/tags/nav-2"},{label:"navigation",permalink:"/docs/tags/navigation"},{label:"simulation",permalink:"/docs/tags/simulation"}],version:"current",sidebarPosition:13,frontMatter:{title:"Isaac Sim to Nav2 Integration",description:"Integration examples showing how Isaac Sim environments are used for Nav2 navigation testing and validation",sidebar_position:13,tags:["integration","isaac-sim","nav2","navigation","simulation"]},sidebar:"tutorialSidebar",previous:{title:"Isaac ROS to Nav2 Integration",permalink:"/docs/isaac-ros-to-nav2-integration"},next:{title:"Cross-Module References",permalink:"/docs/cross-module-references"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Integration Architecture",id:"integration-architecture",level:2},{value:"Data Flow from Isaac Sim to Nav2",id:"data-flow-from-isaac-sim-to-nav2",level:3},{value:"Key Integration Points",id:"key-integration-points",level:3},{value:"Environment Simulation for Navigation",id:"environment-simulation-for-navigation",level:2},{value:"Creating Navigation Test Environments",id:"creating-navigation-test-environments",level:3},{value:"Sensor Simulation for Navigation",id:"sensor-simulation-for-navigation",level:2},{value:"Realistic Sensor Data Generation",id:"realistic-sensor-data-generation",level:3},{value:"Nav2 Integration and Testing",id:"nav2-integration-and-testing",level:2},{value:"Simulation-Based Navigation Testing",id:"simulation-based-navigation-testing",level:3},{value:"Complex Navigation Scenarios",id:"complex-navigation-scenarios",level:2},{value:"Multi-Level Navigation",id:"multi-level-navigation",level:3},{value:"Dynamic Obstacle Navigation",id:"dynamic-obstacle-navigation",level:3},{value:"Performance Validation",id:"performance-validation",level:2},{value:"Navigation Performance Metrics",id:"navigation-performance-metrics",level:3},{value:"Complete Integration Example",id:"complete-integration-example",level:2},{value:"End-to-End Navigation Testing",id:"end-to-end-navigation-testing",level:3},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Isaac Sim to Nav2 Integration Configuration",id:"isaac-sim-to-nav2-integration-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Integration Best Practices",id:"integration-best-practices",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Integration Issues",id:"common-integration-issues",level:3},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"isaac-sim-to-nav2-integration",children:"Isaac Sim to Nav2 Integration"}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"The integration between Isaac Sim and Nav2 enables comprehensive testing and validation of navigation algorithms in realistic simulation environments. This document provides detailed examples of how Isaac Sim environments can be used for Nav2 navigation testing, including simulated navigation scenarios, environment validation, and simulation-to-reality transfer techniques."}),"\n",(0,t.jsx)(n.h2,{id:"integration-architecture",children:"Integration Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"data-flow-from-isaac-sim-to-nav2",children:"Data Flow from Isaac Sim to Nav2"}),"\n",(0,t.jsx)(n.p,{children:"The integration follows a comprehensive data flow that moves from simulation to navigation execution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph LR\n    A[Isaac Sim Environment] --\x3e B[Environment Simulation]\n    A --\x3e C[Sensor Simulation]\n    A --\x3e D[Physics Simulation]\n\n    B --\x3e E[Nav2 Map Generation]\n    C --\x3e F[ROS Sensor Data]\n    D --\x3e G[Robot Dynamics]\n\n    E --\x3e H[Nav2 Costmap]\n    F --\x3e I[Nav2 Localization]\n    G --\x3e J[Nav2 Path Planning]\n\n    H --\x3e K[Nav2 Navigation]\n    I --\x3e K\n    J --\x3e K\n\n    K --\x3e L[Navigation Execution]\n    L --\x3e M[Performance Validation]\n    M --\x3e A\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-integration-points",children:"Key Integration Points"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Simulation"}),": Isaac Sim generates realistic environments for Nav2 testing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Simulation"}),": Isaac Sim provides realistic sensor data for Nav2 localization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physics Simulation"}),": Isaac Sim simulates robot dynamics for realistic navigation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation Framework"}),": Framework for validating navigation performance in simulation"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"environment-simulation-for-navigation",children:"Environment Simulation for Navigation"}),"\n",(0,t.jsx)(n.h3,{id:"creating-navigation-test-environments",children:"Creating Navigation Test Environments"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Creating navigation test environments in Isaac Sim\nfrom omni.isaac.kit import SimulationApp\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.prims import create_prim\nfrom pxr import Gf, UsdGeom\nimport numpy as np\n\nclass IsaacSimNav2Environment:\n    def __init__(self):\n        # Initialize Isaac Sim\n        self.simulation_app = SimulationApp({"headless": False})\n        self.world = World(stage_units_in_meters=1.0)\n\n        # Setup stage\n        self.stage = omni.usd.get_context().get_stage()\n\n        # Navigation-specific parameters\n        self.nav_test_params = {\n            "min_obstacle_clearance": 0.5,  # meters\n            "max_slope_angle": 15.0,        # degrees\n            "step_height_max": 0.2,         # meters\n            "navigation_area_margin": 1.0   # meters\n        }\n\n    def create_navigation_test_environment(self):\n        """\n        Create comprehensive navigation test environment\n        """\n        # Create ground plane\n        self.create_ground_plane()\n\n        # Create static obstacles\n        self.create_static_obstacles()\n\n        # Create dynamic obstacles\n        self.create_dynamic_obstacles()\n\n        # Create navigation test areas\n        self.create_navigation_test_zones()\n\n        # Create complex navigation scenarios\n        self.create_complex_scenarios()\n\n    def create_ground_plane(self):\n        """\n        Create ground plane for navigation\n        """\n        # Create large ground plane\n        ground_prim = UsdGeom.Cone.Define(self.stage, "/World/GroundPlane")\n        ground_mesh = UsdGeom.Mesh.Define(self.stage, "/World/GroundPlane/Mesh")\n\n        # Set ground properties\n        ground_mesh.CreatePointsAttr().Set([\n            (-10, -10, 0), (10, -10, 0), (10, 10, 0), (-10, 10, 0)\n        ])\n        ground_mesh.CreateFaceVertexCountsAttr([4])\n        ground_mesh.CreateFaceVertexIndicesAttr([0, 1, 2, 3])\n\n    def create_static_obstacles(self):\n        """\n        Create static obstacles for navigation testing\n        """\n        # Create various obstacle types\n        obstacle_configs = [\n            {"type": "box", "position": (2, 0, 0), "size": (1, 1, 2)},\n            {"type": "cylinder", "position": (-2, 3, 0), "radius": 0.5, "height": 2},\n            {"type": "wall", "position": (0, -5, 0), "size": (10, 0.2, 2)},\n        ]\n\n        for i, config in enumerate(obstacle_configs):\n            self.create_obstacle(f"/World/StaticObstacles/Obstacle_{i}", config)\n\n    def create_dynamic_obstacles(self):\n        """\n        Create dynamic obstacles for navigation testing\n        """\n        # Create moving obstacles\n        moving_obstacles = [\n            {"type": "person", "position": (3, 2, 0), "movement_pattern": "circular"},\n            {"type": "box", "position": (-3, -2, 0), "movement_pattern": "linear"},\n        ]\n\n        for i, config in enumerate(moving_obstacles):\n            self.create_moving_obstacle(f"/World/DynamicObstacles/MovingObstacle_{i}", config)\n\n    def create_navigation_test_zones(self):\n        """\n        Create specific zones for navigation testing\n        """\n        # Create narrow passages\n        self.create_narrow_passage((0, 5, 0), width=0.8, length=2.0)\n\n        # Create open areas\n        self.create_open_area((5, 5, 0), radius=3.0)\n\n        # Create cluttered areas\n        self.create_cluttered_area((-5, -5, 0), size=(4, 4))\n\n    def create_complex_scenarios(self):\n        """\n        Create complex navigation scenarios\n        """\n        # Create multi-level navigation (stairs/ramps)\n        self.create_stairs_scenario()\n\n        # Create crowded navigation\n        self.create_crowded_scenario()\n\n        # Create dynamic obstacle avoidance\n        self.create_dynamic_avoidance_scenario()\n\n    def create_stairs_scenario(self):\n        """\n        Create stairs scenario for Z-axis navigation testing\n        """\n        # Create step-by-step stairs\n        for i in range(5):\n            step_height = 0.15 * i  # 15cm per step\n            step_depth = 0.30\n            step_width = 0.80\n\n            step_position = (i * step_depth, 0, step_height)\n            step_prim = UsdGeom.Cube.Define(\n                self.stage,\n                f"/World/Stairs/Step_{i}"\n            )\n            step_prim.CreateSizeAttr(1.0)\n            step_prim.AddTranslateOp().Set(Gf.Vec3d(*step_position))\n\n    def create_crowded_scenario(self):\n        """\n        Create crowded scenario with multiple obstacles\n        """\n        # Create multiple obstacles in a confined space\n        for i in range(10):\n            x = np.random.uniform(-2, 2)\n            y = np.random.uniform(-2, 2)\n            z = 0.5\n\n            obstacle_prim = UsdGeom.Cylinder.Define(\n                self.stage,\n                f"/World/CrowdedArea/Obstacle_{i}"\n            )\n            obstacle_prim.CreateRadiusAttr(0.3)\n            obstacle_prim.CreateHeightAttr(1.0)\n            obstacle_prim.AddTranslateOp().Set(Gf.Vec3d(x, y, z))\n\n    def create_dynamic_avoidance_scenario(self):\n        """\n        Create dynamic obstacle avoidance scenario\n        """\n        # Create moving obstacles with predictable patterns\n        moving_patterns = [\n            {"type": "circular", "center": (0, 0, 0), "radius": 2.0, "speed": 0.5},\n            {"type": "linear", "start": (-3, 0, 0), "end": (3, 0, 0), "speed": 0.3},\n        ]\n\n        for i, pattern in enumerate(moving_patterns):\n            self.create_moving_pattern(f"/World/DynamicAvoidance/Pattern_{i}", pattern)\n\n    def create_obstacle(self, path, config):\n        """\n        Create obstacle based on configuration\n        """\n        if config["type"] == "box":\n            prim = UsdGeom.Cube.Define(self.stage, path)\n            prim.CreateSizeAttr(config["size"][0])\n            prim.AddTranslateOp().Set(Gf.Vec3d(*config["position"]))\n        elif config["type"] == "cylinder":\n            prim = UsdGeom.Cylinder.Define(self.stage, path)\n            prim.CreateRadiusAttr(config["radius"])\n            prim.CreateHeightAttr(config["height"])\n            prim.AddTranslateOp().Set(Gf.Vec3d(*config["position"]))\n\n    def create_narrow_passage(self, center, width, length):\n        """\n        Create narrow passage for navigation testing\n        """\n        # Create walls on both sides\n        left_wall_pos = (center[0] - width/2 - 0.1, center[1], center[2])\n        right_wall_pos = (center[0] + width/2 + 0.1, center[1], center[2])\n\n        left_wall = UsdGeom.Cube.Define(self.stage, f"/World/NarrowPassage/LeftWall")\n        left_wall.CreateSizeAttr(0.2)\n        left_wall.AddTranslateOp().Set(Gf.Vec3d(*left_wall_pos))\n\n        right_wall = UsdGeom.Cube.Define(self.stage, f"/World/NarrowPassage/RightWall")\n        right_wall.CreateSizeAttr(0.2)\n        right_wall.AddTranslateOp().Set(Gf.Vec3d(*right_wall_pos))\n\n    def create_open_area(self, center, radius):\n        """\n        Create open area for navigation testing\n        """\n        # Create circular open area by removing obstacles\n        pass  # Implementation would clear obstacles in circular area\n\n    def create_moving_obstacle(self, path, config):\n        """\n        Create moving obstacle with specified pattern\n        """\n        # Create the obstacle\n        obstacle = UsdGeom.Sphere.Define(self.stage, path)\n        obstacle.CreateRadiusAttr(0.3)\n        obstacle.AddTranslateOp().Set(Gf.Vec3d(*config["position"]))\n\n    def create_moving_pattern(self, path, pattern):\n        """\n        Create moving pattern for dynamic obstacles\n        """\n        # Implementation would create animation or movement script\n        pass\n'})}),"\n",(0,t.jsx)(n.h2,{id:"sensor-simulation-for-navigation",children:"Sensor Simulation for Navigation"}),"\n",(0,t.jsx)(n.h3,{id:"realistic-sensor-data-generation",children:"Realistic Sensor Data Generation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Isaac Sim sensor simulation for Nav2 navigation\nfrom omni.isaac.core.sensors import ImuSensor, Camera, Lidar\nfrom omni.isaac.range_sensor import _range_sensor\nimport carb\nimport numpy as np\n\nclass IsaacSimSensorSimulator:\n    def __init__(self, world):\n        self.world = world\n        self.sensors = {}\n        self.sensor_data = {}\n\n    def setup_navigation_sensors(self, robot_prim_path):\n        """\n        Setup sensors for navigation testing\n        """\n        # Setup camera for visual navigation\n        self.setup_camera_sensor(robot_prim_path)\n\n        # Setup LiDAR for 3D navigation\n        self.setup_lidar_sensor(robot_prim_path)\n\n        # Setup IMU for balance and orientation\n        self.setup_imu_sensor(robot_prim_path)\n\n        # Setup depth camera for obstacle detection\n        self.setup_depth_camera(robot_prim_path)\n\n    def setup_camera_sensor(self, robot_prim_path):\n        """\n        Setup camera sensor for visual navigation\n        """\n        camera_path = f"{robot_prim_path}/Camera"\n\n        # Create camera in Isaac Sim\n        self.camera = Camera(\n            prim_path=camera_path,\n            frequency=30,\n            resolution=(640, 480),\n            position=np.array([0.2, 0, 0.8]),  # Head position\n            orientation=np.array([0, 0, 0, 1])\n        )\n\n        # Add to world\n        self.world.scene.add_sensor(self.camera)\n\n        self.sensors[\'camera\'] = self.camera\n\n    def setup_lidar_sensor(self, robot_prim_path):\n        """\n        Setup LiDAR sensor for navigation\n        """\n        lidar_path = f"{robot_prim_path}/Lidar"\n\n        # Create LiDAR in Isaac Sim\n        self.lidar = self.world.scene.add(\n            "lidar",\n            prim_path=lidar_path,\n            translation=np.array([0.1, 0, 0.5]),  # Torso position\n            orientation=np.array([0, 0, 0, 1]),\n            config="Yamaha-70cm",\n            min_range=0.1,\n            max_range=10.0\n        )\n\n        self.sensors[\'lidar\'] = self.lidar\n\n    def setup_imu_sensor(self, robot_prim_path):\n        """\n        Setup IMU sensor for navigation\n        """\n        imu_path = f"{robot_prim_path}/Imu"\n\n        # Create IMU in Isaac Sim\n        self.imu = ImuSensor(\n            prim_path=imu_path,\n            frequency=100,\n            position=np.array([0, 0, 0.8]),  # Body center\n            orientation=np.array([0, 0, 0, 1])\n        )\n\n        self.world.scene.add_sensor(self.imu)\n        self.sensors[\'imu\'] = self.imu\n\n    def setup_depth_camera(self, robot_prim_path):\n        """\n        Setup depth camera for obstacle detection\n        """\n        depth_cam_path = f"{robot_prim_path}/DepthCamera"\n\n        # Create depth camera in Isaac Sim\n        self.depth_camera = Camera(\n            prim_path=depth_cam_path,\n            frequency=30,\n            resolution=(640, 480),\n            position=np.array([0.2, 0, 0.8]),\n            orientation=np.array([0, 0, 0, 1]),\n            sensor_type="depth"\n        )\n\n        self.world.scene.add_sensor(self.depth_camera)\n        self.sensors[\'depth_camera\'] = self.depth_camera\n\n    def get_sensor_data(self):\n        """\n        Get current sensor data for Nav2\n        """\n        sensor_data = {}\n\n        # Get camera data\n        if \'camera\' in self.sensors:\n            sensor_data[\'camera\'] = self.sensors[\'camera\'].get_current_frame()\n\n        # Get LiDAR data\n        if \'lidar\' in self.sensors:\n            sensor_data[\'lidar\'] = self.sensors[\'lidar\'].get_linear_depth_data()\n\n        # Get IMU data\n        if \'imu\' in self.sensors:\n            sensor_data[\'imu\'] = self.sensors[\'imu\'].get_measured_value()\n\n        # Get depth camera data\n        if \'depth_camera\' in self.sensors:\n            sensor_data[\'depth\'] = self.sensors[\'depth_camera\'].get_current_frame()\n\n        return sensor_data\n\n    def convert_to_ros_format(self, sensor_data):\n        """\n        Convert Isaac Sim sensor data to ROS format for Nav2\n        """\n        ros_data = {}\n\n        # Convert camera data to sensor_msgs/Image\n        if \'camera\' in sensor_data:\n            ros_data[\'camera\'] = self.convert_image_to_ros(sensor_data[\'camera\'])\n\n        # Convert LiDAR data to sensor_msgs/LaserScan or sensor_msgs/PointCloud2\n        if \'lidar\' in sensor_data:\n            ros_data[\'lidar\'] = self.convert_lidar_to_ros(sensor_data[\'lidar\'])\n\n        # Convert IMU data to sensor_msgs/Imu\n        if \'imu\' in sensor_data:\n            ros_data[\'imu\'] = self.convert_imu_to_ros(sensor_data[\'imu\'])\n\n        # Convert depth data to sensor_msgs/Image\n        if \'depth\' in sensor_data:\n            ros_data[\'depth\'] = self.convert_depth_to_ros(sensor_data[\'depth\'])\n\n        return ros_data\n\n    def convert_image_to_ros(self, image_data):\n        """\n        Convert Isaac Sim image to ROS Image message\n        """\n        from sensor_msgs.msg import Image\n        from cv_bridge import CvBridge\n\n        bridge = CvBridge()\n        ros_image = bridge.cv2_to_imgmsg(image_data, encoding="bgr8")\n        return ros_image\n\n    def convert_lidar_to_ros(self, lidar_data):\n        """\n        Convert Isaac Sim LiDAR data to ROS LaserScan message\n        """\n        from sensor_msgs.msg import LaserScan\n\n        scan_msg = LaserScan()\n        scan_msg.angle_min = -np.pi / 2\n        scan_msg.angle_max = np.pi / 2\n        scan_msg.angle_increment = np.pi / 180  # 1 degree\n        scan_msg.range_min = 0.1\n        scan_msg.range_max = 10.0\n        scan_msg.ranges = lidar_data.flatten().tolist()\n\n        return scan_msg\n\n    def convert_imu_to_ros(self, imu_data):\n        """\n        Convert Isaac Sim IMU data to ROS Imu message\n        """\n        from sensor_msgs.msg import Imu\n\n        imu_msg = Imu()\n        imu_msg.linear_acceleration.x = imu_data[\'linear_acceleration\'][0]\n        imu_msg.linear_acceleration.y = imu_data[\'linear_acceleration\'][1]\n        imu_msg.linear_acceleration.z = imu_data[\'linear_acceleration\'][2]\n        imu_msg.angular_velocity.x = imu_data[\'angular_velocity\'][0]\n        imu_msg.angular_velocity.y = imu_data[\'angular_velocity\'][1]\n        imu_msg.angular_velocity.z = imu_data[\'angular_velocity\'][2]\n\n        return imu_msg\n'})}),"\n",(0,t.jsx)(n.h2,{id:"nav2-integration-and-testing",children:"Nav2 Integration and Testing"}),"\n",(0,t.jsx)(n.h3,{id:"simulation-based-navigation-testing",children:"Simulation-Based Navigation Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Nav2 navigation testing in Isaac Sim environment\nimport rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nfrom action_msgs.msg import GoalStatus\nimport time\n\nclass IsaacSimNav2Tester:\n    def __init__(self, isaac_sim_env, sensor_simulator):\n        self.isaac_sim_env = isaac_sim_env\n        self.sensor_simulator = sensor_simulator\n\n        # Initialize ROS2\n        if not rclpy.ok():\n            rclpy.init()\n\n        # Create navigation node\n        self.nav_node = rclpy.create_node(\'isaac_sim_nav2_tester\')\n\n        # Create action client for navigation\n        self.nav_client = ActionClient(\n            self.nav_node,\n            NavigateToPose,\n            \'navigate_to_pose\'\n        )\n\n        # Navigation test parameters\n        self.test_params = {\n            "max_navigation_time": 300.0,  # 5 minutes\n            "min_success_distance": 0.5,    # meters\n            "test_retries": 3\n        }\n\n    def run_navigation_tests(self):\n        """\n        Run comprehensive navigation tests in Isaac Sim\n        """\n        test_scenarios = [\n            {"name": "open_area", "goal": (5, 5, 0)},\n            {"name": "narrow_passage", "goal": (-3, 2, 0)},\n            {"name": "obstacle_avoidance", "goal": (0, -5, 0)},\n            {"name": "dynamic_obstacle", "goal": (3, -3, 0)},\n        ]\n\n        results = {}\n\n        for scenario in test_scenarios:\n            print(f"Running test: {scenario[\'name\']}")\n            result = self.run_single_navigation_test(scenario)\n            results[scenario["name"]] = result\n\n        return results\n\n    def run_single_navigation_test(self, scenario):\n        """\n        Run a single navigation test scenario\n        """\n        # Set up the scenario in Isaac Sim\n        self.setup_scenario(scenario)\n\n        # Wait for Isaac Sim to settle\n        self.isaac_sim_env.world.step(render=True)\n\n        # Create navigation goal\n        goal_pose = self.create_goal_pose(scenario["goal"])\n\n        # Execute navigation\n        start_time = time.time()\n        success = self.execute_navigation(goal_pose)\n        end_time = time.time()\n\n        # Collect results\n        result = {\n            "success": success,\n            "time_taken": end_time - start_time,\n            "scenario": scenario["name"],\n            "goal": scenario["goal"]\n        }\n\n        return result\n\n    def setup_scenario(self, scenario):\n        """\n        Set up specific scenario in Isaac Sim\n        """\n        # Reset Isaac Sim environment\n        self.isaac_sim_env.world.reset()\n\n        # Configure scenario-specific elements\n        if scenario["name"] == "narrow_passage":\n            # Ensure narrow passage is clearable\n            pass\n        elif scenario["name"] == "dynamic_obstacle":\n            # Activate dynamic obstacles\n            self.activate_dynamic_obstacles()\n        elif scenario["name"] == "obstacle_avoidance":\n            # Ensure obstacles are in place\n            pass\n\n    def create_goal_pose(self, goal_position):\n        """\n        Create goal pose for navigation\n        """\n        goal_pose = PoseStamped()\n        goal_pose.header.frame_id = "map"\n        goal_pose.header.stamp = self.nav_node.get_clock().now().to_msg()\n\n        goal_pose.pose.position.x = goal_position[0]\n        goal_pose.pose.position.y = goal_position[1]\n        goal_pose.pose.position.z = goal_position[2]\n\n        # Set orientation (facing forward)\n        goal_pose.pose.orientation.w = 1.0\n\n        return goal_pose\n\n    def execute_navigation(self, goal_pose):\n        """\n        Execute navigation to goal pose\n        """\n        # Wait for action server\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\n            print("Navigation action server not available")\n            return False\n\n        # Create navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = goal_pose\n\n        # Send navigation goal\n        future = self.nav_client.send_goal_async(goal_msg)\n        future.add_done_callback(self.navigation_goal_callback)\n\n        # Wait for result\n        rclpy.spin_until_future_complete(self.nav_node, future)\n\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            print("Navigation goal rejected")\n            return False\n\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self.nav_node, result_future)\n\n        result = result_future.result().result\n        status = result_future.result().status\n\n        return status == GoalStatus.STATUS_SUCCEEDED\n\n    def navigation_goal_callback(self, future):\n        """\n        Handle navigation goal response\n        """\n        goal_handle = future.result()\n        if goal_handle.accepted:\n            print("Navigation goal accepted")\n        else:\n            print("Navigation goal rejected")\n\n    def activate_dynamic_obstacles(self):\n        """\n        Activate dynamic obstacles for testing\n        """\n        # Implementation would activate moving obstacles\n        pass\n\n    def get_performance_metrics(self, test_results):\n        """\n        Calculate performance metrics from test results\n        """\n        metrics = {\n            "success_rate": 0,\n            "average_time": 0,\n            "total_tests": len(test_results),\n            "successful_tests": 0,\n            "total_time": 0\n        }\n\n        successful_times = []\n        for result in test_results.values():\n            if result["success"]:\n                metrics["successful_tests"] += 1\n                successful_times.append(result["time_taken"])\n                metrics["total_time"] += result["time_taken"]\n\n        if metrics["successful_tests"] > 0:\n            metrics["success_rate"] = metrics["successful_tests"] / metrics["total_tests"]\n            metrics["average_time"] = sum(successful_times) / len(successful_times)\n\n        return metrics\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complex-navigation-scenarios",children:"Complex Navigation Scenarios"}),"\n",(0,t.jsx)(n.h3,{id:"multi-level-navigation",children:"Multi-Level Navigation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Multi-level navigation in Isaac Sim\nclass MultiLevelNavigationTester:\n    def __init__(self, isaac_sim_env):\n        self.isaac_sim_env = isaac_sim_env\n\n    def create_multi_level_environment(self):\n        """\n        Create multi-level navigation environment (stairs, ramps, etc.)\n        """\n        # Create ground level\n        self.create_ground_level()\n\n        # Create first floor\n        self.create_first_floor()\n\n        # Create stairs connecting levels\n        self.create_stairs()\n\n        # Create ramps\n        self.create_ramps()\n\n    def create_ground_level(self):\n        """\n        Create ground level environment\n        """\n        # Create main ground area\n        ground_plane = UsdGeom.Cone.Define(\n            self.isaac_sim_env.stage,\n            "/World/GroundLevel/GroundPlane"\n        )\n        ground_plane.CreateSizeAttr(20.0)\n\n    def create_first_floor(self):\n        """\n        Create first floor environment\n        """\n        # Create elevated platform\n        first_floor = UsdGeom.Cube.Define(\n            self.isaac_sim_env.stage,\n            "/World/FirstFloor/Platform"\n        )\n        first_floor.CreateSizeAttr(10.0)\n        first_floor.AddTranslateOp().Set(Gf.Vec3d(0, 0, 2.0))  # 2m elevation\n\n    def create_stairs(self):\n        """\n        Create stairs for level transition\n        """\n        # Create individual steps\n        for i in range(10):\n            step_height = 0.15 * i  # 15cm per step\n            step_depth = 0.30\n            step_width = 0.80\n\n            step_position = (i * step_depth - 1.5, 0, step_height)\n            step_prim = UsdGeom.Cube.Define(\n                self.isaac_sim_env.stage,\n                f"/World/Stairs/Step_{i}"\n            )\n            step_prim.CreateSizeAttr(1.0)\n            step_prim.AddTranslateOp().Set(Gf.Vec3d(*step_position))\n\n    def create_ramps(self):\n        """\n        Create ramps for gradual elevation change\n        """\n        # Create ramp object\n        ramp = UsdGeom.Mesh.Define(\n            self.isaac_sim_env.stage,\n            "/World/Ramps/Ramp_0"\n        )\n        # Set ramp geometry (simplified)\n        ramp.AddTranslateOp().Set(Gf.Vec3d(5, 0, 0))\n\n    def test_multi_level_navigation(self):\n        """\n        Test multi-level navigation capabilities\n        """\n        navigation_tests = [\n            {"start": (0, 0, 0), "goal": (5, 0, 2.0), "description": "Ground to first floor via stairs"},\n            {"start": (5, 0, 2.0), "goal": (0, 0, 0), "description": "First floor to ground via stairs"},\n            {"start": (-5, 0, 0), "goal": (10, 0, 1.0), "description": "Ramp navigation"},\n        ]\n\n        results = {}\n        for test in navigation_tests:\n            print(f"Testing: {test[\'description\']}")\n            result = self.execute_multi_level_test(test)\n            results[test["description"]] = result\n\n        return results\n\n    def execute_multi_level_test(self, test):\n        """\n        Execute multi-level navigation test\n        """\n        # Implementation would handle multi-level navigation\n        # This would include Z-axis navigation and step planning\n        return {"success": True, "time": 45.0}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-obstacle-navigation",children:"Dynamic Obstacle Navigation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Dynamic obstacle navigation testing\nclass DynamicObstacleTester:\n    def __init__(self, isaac_sim_env):\n        self.isaac_sim_env = isaac_sim_env\n        self.dynamic_obstacles = []\n\n    def create_dynamic_obstacle_scenario(self):\n        """\n        Create scenario with dynamic obstacles\n        """\n        # Create moving obstacles with different patterns\n        obstacle_configs = [\n            {"type": "person", "path": "circular", "center": (0, 0, 0), "radius": 2.0, "speed": 0.5},\n            {"type": "box", "path": "linear", "start": (-3, 0, 0), "end": (3, 0, 0), "speed": 0.3},\n            {"type": "cylinder", "path": "oscillating", "center": (0, 3, 0), "amplitude": 1.0, "frequency": 0.5},\n        ]\n\n        for i, config in enumerate(obstacle_configs):\n            obstacle = self.create_dynamic_obstacle(f"DynamicObstacle_{i}", config)\n            self.dynamic_obstacles.append(obstacle)\n\n    def create_dynamic_obstacle(self, name, config):\n        """\n        Create dynamic obstacle with specified movement pattern\n        """\n        # Create obstacle in Isaac Sim\n        obstacle_prim = UsdGeom.Sphere.Define(\n            self.isaac_sim_env.stage,\n            f"/World/DynamicObstacles/{name}"\n        )\n        obstacle_prim.CreateRadiusAttr(0.3)\n        obstacle_prim.AddTranslateOp().Set(Gf.Vec3d(*config["start"]))\n\n        # Return obstacle object with movement pattern\n        return {\n            "prim": obstacle_prim,\n            "config": config,\n            "current_position": config["start"]\n        }\n\n    def update_dynamic_obstacles(self, time_step):\n        """\n        Update positions of dynamic obstacles\n        """\n        for obstacle in self.dynamic_obstacles:\n            new_position = self.calculate_new_position(\n                obstacle, time_step\n            )\n            obstacle["prim"].AddTranslateOp().Set(Gf.Vec3d(*new_position))\n            obstacle["current_position"] = new_position\n\n    def calculate_new_position(self, obstacle, time_step):\n        """\n        Calculate new position based on movement pattern\n        """\n        config = obstacle["config"]\n        current_pos = obstacle["current_position"]\n\n        if config["path"] == "circular":\n            # Calculate circular motion\n            angle = time.time() * config["speed"]\n            new_x = config["center"][0] + config["radius"] * np.cos(angle)\n            new_y = config["center"][1] + config["radius"] * np.sin(angle)\n            return (new_x, new_y, current_pos[2])\n\n        elif config["path"] == "linear":\n            # Calculate linear back-and-forth motion\n            direction = np.sign(np.sin(time.time() * config["speed"]))\n            distance = (time.time() * config["speed"]) % 6  # Oscillate between 6 units\n            new_x = config["start"][0] + distance * direction\n            return (new_x, current_pos[1], current_pos[2])\n\n        return current_pos\n\n    def test_dynamic_navigation(self):\n        """\n        Test navigation with dynamic obstacles\n        """\n        # Set up dynamic obstacle scenario\n        self.create_dynamic_obstacle_scenario()\n\n        # Run navigation tests with moving obstacles\n        navigation_tests = [\n            {"start": (-5, -5, 0), "goal": (5, 5, 0), "description": "Crossing moving obstacles"},\n            {"start": (0, -5, 0), "goal": (0, 5, 0), "description": "Passing circular obstacle"},\n        ]\n\n        results = {}\n        for test in navigation_tests:\n            print(f"Testing dynamic navigation: {test[\'description\']}")\n            result = self.execute_dynamic_test(test)\n            results[test["description"]] = result\n\n        return results\n\n    def execute_dynamic_test(self, test):\n        """\n        Execute dynamic navigation test\n        """\n        # Implementation would run navigation while obstacles move\n        # This tests dynamic obstacle avoidance capabilities\n        return {"success": True, "time": 60.0, "obstacles_avoided": 3}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-validation",children:"Performance Validation"}),"\n",(0,t.jsx)(n.h3,{id:"navigation-performance-metrics",children:"Navigation Performance Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Navigation performance validation\nclass NavigationPerformanceValidator:\n    def __init__(self):\n        self.metrics = {\n            "success_rate": [],\n            "navigation_time": [],\n            "path_efficiency": [],\n            "obstacle_avoidance": [],\n            "localization_accuracy": []\n        }\n\n    def validate_navigation_performance(self, test_results):\n        """\n        Validate navigation performance based on test results\n        """\n        validation_report = {\n            "overall_success_rate": 0,\n            "average_navigation_time": 0,\n            "path_efficiency_score": 0,\n            "obstacle_avoidance_success": 0,\n            "localization_accuracy": 0,\n            "recommendations": []\n        }\n\n        # Calculate success rate\n        successful_navigations = sum(1 for result in test_results if result.get("success", False))\n        total_navigations = len(test_results)\n        validation_report["overall_success_rate"] = successful_navigations / total_navigations if total_navigations > 0 else 0\n\n        # Calculate average navigation time\n        successful_times = [result["time_taken"] for result in test_results if result.get("success", False)]\n        if successful_times:\n            validation_report["average_navigation_time"] = sum(successful_times) / len(successful_times)\n\n        # Calculate path efficiency (ratio of actual path to straight-line distance)\n        validation_report["path_efficiency_score"] = self.calculate_path_efficiency(test_results)\n\n        # Calculate obstacle avoidance success\n        validation_report["obstacle_avoidance_success"] = self.calculate_obstacle_avoidance_success(test_results)\n\n        # Generate recommendations based on performance\n        validation_report["recommendations"] = self.generate_recommendations(validation_report)\n\n        return validation_report\n\n    def calculate_path_efficiency(self, test_results):\n        """\n        Calculate path efficiency score\n        """\n        # Compare actual path length to straight-line distance\n        efficiency_scores = []\n        for result in test_results:\n            if result.get("success", False) and "path_length" in result and "straight_line_distance" in result:\n                efficiency = result["straight_line_distance"] / result["path_length"]\n                efficiency_scores.append(min(efficiency, 1.0))  # Cap at 1.0\n\n        return sum(efficiency_scores) / len(efficiency_scores) if efficiency_scores else 0\n\n    def calculate_obstacle_avoidance_success(self, test_results):\n        """\n        Calculate obstacle avoidance success rate\n        """\n        avoidance_successes = sum(1 for result in test_results if result.get("obstacle_avoided", False))\n        total_with_obstacles = sum(1 for result in test_results if "obstacles_present" in result)\n\n        return avoidance_successes / total_with_obstacles if total_with_obstacles > 0 else 0\n\n    def generate_recommendations(self, validation_report):\n        """\n        Generate recommendations based on validation results\n        """\n        recommendations = []\n\n        if validation_report["overall_success_rate"] < 0.8:\n            recommendations.append("Navigation success rate is low (<80%), consider improving path planning algorithms")\n\n        if validation_report["average_navigation_time"] > 60:  # More than 1 minute\n            recommendations.append("Average navigation time is high, consider optimizing path planning")\n\n        if validation_report["path_efficiency_score"] < 0.7:\n            recommendations.append("Path efficiency is low, consider improving path optimization")\n\n        if validation_report["obstacle_avoidance_success"] < 0.9:\n            recommendations.append("Obstacle avoidance success rate is low, consider improving dynamic obstacle detection")\n\n        return recommendations\n\n    def generate_validation_report(self, test_results, environment_description):\n        """\n        Generate comprehensive validation report\n        """\n        validation_report = self.validate_navigation_performance(test_results)\n\n        report = {\n            "environment": environment_description,\n            "validation_date": time.strftime("%Y-%m-%d %H:%M:%S"),\n            "test_results": test_results,\n            "performance_metrics": validation_report,\n            "sim_to_real_transfer_readiness": self.assess_sim_to_real_readiness(validation_report)\n        }\n\n        return report\n\n    def assess_sim_to_real_readiness(self, validation_report):\n        """\n        Assess readiness for real-world deployment based on simulation results\n        """\n        readiness_score = 0\n\n        # Weight different metrics\n        if validation_report["overall_success_rate"] >= 0.9:\n            readiness_score += 25\n        elif validation_report["overall_success_rate"] >= 0.8:\n            readiness_score += 15\n        elif validation_report["overall_success_rate"] >= 0.7:\n            readiness_score += 5\n\n        if validation_report["path_efficiency_score"] >= 0.8:\n            readiness_score += 25\n        elif validation_report["path_efficiency_score"] >= 0.7:\n            readiness_score += 15\n        elif validation_report["path_efficiency_score"] >= 0.6:\n            readiness_score += 5\n\n        if validation_report["obstacle_avoidance_success"] >= 0.9:\n            readiness_score += 25\n        elif validation_report["obstacle_avoidance_success"] >= 0.8:\n            readiness_score += 15\n        elif validation_report["obstacle_avoidance_success"] >= 0.7:\n            readiness_score += 5\n\n        # Additional factors\n        if "recommendations" in validation_report and len(validation_report["recommendations"]) == 0:\n            readiness_score += 25\n\n        readiness_level = "LOW"\n        if readiness_score >= 80:\n            readiness_level = "HIGH"\n        elif readiness_score >= 50:\n            readiness_level = "MEDIUM"\n\n        return {\n            "score": readiness_score,\n            "level": readiness_level,\n            "factors": validation_report["recommendations"]\n        }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-integration-example",children:"Complete Integration Example"}),"\n",(0,t.jsx)(n.h3,{id:"end-to-end-navigation-testing",children:"End-to-End Navigation Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Complete Isaac Sim to Nav2 integration example\ndef complete_navigation_integration_test():\n    """\n    Complete integration test: Isaac Sim to Nav2 navigation\n    """\n    print("Starting complete Isaac Sim to Nav2 integration test...")\n\n    # Step 1: Initialize Isaac Sim environment\n    print("1. Initializing Isaac Sim environment...")\n    isaac_env = IsaacSimNav2Environment()\n    isaac_env.create_navigation_test_environment()\n\n    # Step 2: Setup sensor simulation\n    print("2. Setting up sensor simulation...")\n    sensor_sim = IsaacSimSensorSimulator(isaac_env.world)\n    sensor_sim.setup_navigation_sensors("/World/Robot")\n\n    # Step 3: Run navigation tests\n    print("3. Running navigation tests...")\n    nav_tester = IsaacSimNav2Tester(isaac_env, sensor_sim)\n    test_results = nav_tester.run_navigation_tests()\n\n    # Step 4: Test complex scenarios\n    print("4. Testing complex scenarios...")\n    multi_level_tester = MultiLevelNavigationTester(isaac_env)\n    multi_level_results = multi_level_tester.test_multi_level_navigation()\n\n    dynamic_tester = DynamicObstacleTester(isaac_env)\n    dynamic_results = dynamic_tester.test_dynamic_navigation()\n\n    # Step 5: Validate performance\n    print("5. Validating performance...")\n    validator = NavigationPerformanceValidator()\n    validation_report = validator.generate_validation_report(\n        list(test_results.values()) + list(multi_level_results.values()) + list(dynamic_results.values()),\n        "Comprehensive Isaac Sim Navigation Test Environment"\n    )\n\n    # Step 6: Generate final report\n    print("6. Generating final report...")\n    final_report = {\n        "integration_test_results": {\n            "basic_navigation": test_results,\n            "multi_level": multi_level_results,\n            "dynamic_obstacles": dynamic_results\n        },\n        "performance_validation": validation_report,\n        "sim_to_real_readiness": validation_report["sim_to_real_transfer_readiness"]\n    }\n\n    print(f"Integration test completed. Readiness level: {validation_report[\'sim_to_real_transfer_readiness\'][\'level\']}")\n    print(f"Success rate: {validation_report[\'performance_metrics\'][\'overall_success_rate\']:.2%}")\n\n    return final_report\n\n# Example usage\nif __name__ == "__main__":\n    report = complete_navigation_integration_test()\n    print("\\nFinal Integration Report:")\n    print(f"Success Rate: {report[\'performance_validation\'][\'performance_metrics\'][\'overall_success_rate\']:.2%}")\n    print(f"Readiness Level: {report[\'performance_validation\'][\'sim_to_real_transfer_readiness\'][\'level\']}")\n    print(f"Recommendations: {len(report[\'performance_validation\'][\'performance_metrics\'][\'recommendations\'])}")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"isaac-sim-to-nav2-integration-configuration",children:"Isaac Sim to Nav2 Integration Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# Isaac Sim to Nav2 integration configuration\nisaac_sim_nav2_integration:\n  ros__parameters:\n    # Simulation parameters\n    simulation:\n      enable_physics: true\n      physics_engine: "physx"\n      update_frequency: 60.0\n      enable_rendering: true\n      rendering_frequency: 30.0\n\n    # Environment parameters\n    environment:\n      enable_domain_randomization: false\n      enable_texture_randomization: false\n      enable_lighting_randomization: false\n      enable_obstacle_randomization: true\n\n    # Sensor parameters\n    sensors:\n      camera:\n        enable: true\n        resolution: [640, 480]\n        frequency: 30.0\n        fov: 60.0\n      lidar:\n        enable: true\n        frequency: 10.0\n        range_min: 0.1\n        range_max: 10.0\n        points_per_rotation: 360\n      imu:\n        enable: true\n        frequency: 100.0\n        noise_density: 0.01\n      depth_camera:\n        enable: true\n        resolution: [640, 480]\n        frequency: 30.0\n\n    # Navigation testing parameters\n    navigation_testing:\n      enable_automatic_tests: true\n      test_scenarios: ["open_area", "obstacle_avoidance", "narrow_passage", "dynamic_obstacles"]\n      max_test_time: 300.0  # 5 minutes per test\n      goal_tolerance: 0.5\n      retry_count: 3\n\n    # Validation parameters\n    validation:\n      success_threshold: 0.8  # 80% success rate required\n      time_threshold: 120.0   # Max 2 minutes per navigation\n      efficiency_threshold: 0.7  # 70% path efficiency required\n      obstacle_avoidance_threshold: 0.9  # 90% obstacle avoidance success\n\n# Nav2 configuration for simulation\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True  # Use simulation time\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 50\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.2\n      vy_std: 0.1\n      wz_std: 0.4\n      vx_max: 0.5\n      vx_min: -0.1\n      vy_max: 0.3\n      wz_max: 0.5\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"integration-best-practices",children:"Integration Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Realism"}),": Create realistic environments that match real-world conditions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Accuracy"}),": Ensure simulated sensors closely match real sensor characteristics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physics Fidelity"}),": Use accurate physics simulation for realistic robot behavior"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Comprehensive Testing"}),": Test navigation in diverse scenarios and conditions"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Progressive Complexity"}),": Start with simple scenarios and increase complexity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Edge Case Testing"}),": Test edge cases and failure scenarios"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Monitoring"}),": Monitor navigation performance metrics continuously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation Framework"}),": Implement comprehensive validation of simulation results"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"common-integration-issues",children:"Common Integration Issues"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# Troubleshooting guide for Isaac Sim to Nav2 integration\ntroubleshooting:\n  common_issues:\n    - issue: "Simulation-Reality Gap"\n      symptoms:\n        - "High success rate in simulation but low in real world"\n        - "Different navigation behavior in sim vs reality"\n      causes:\n        - "Insufficient domain randomization"\n        - "Inaccurate sensor simulation"\n        - "Physics differences between sim and reality"\n      solutions:\n        - "Increase domain randomization in simulation"\n        - "Improve sensor simulation accuracy"\n        - "Validate physics parameters against real robot"\n\n    - issue: "Performance Degradation in Simulation"\n      symptoms:\n        - "Slow navigation in simulation"\n        - "High computational load"\n      causes:\n        - "Complex environment rendering"\n        - "High-frequency sensor simulation"\n        - "Inefficient path planning"\n      solutions:\n        - "Optimize environment complexity"\n        - "Throttle sensor frequencies appropriately"\n        - "Optimize path planning algorithms"\n\n    - issue: "Localization Drift in Simulation"\n      symptoms:\n        - "Robot position estimation drifts over time"\n        - "Navigation fails due to poor localization"\n      causes:\n        - "Inaccurate odometry simulation"\n        - "Insufficient sensor data"\n        - "Poor environment features"\n      solutions:\n        - "Improve odometry simulation accuracy"\n        - "Add additional sensors for localization"\n        - "Enhance environment with distinctive features"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The integration between Isaac Sim and Nav2 provides a powerful framework for testing and validating navigation algorithms in realistic simulation environments. By creating comprehensive test scenarios, realistic sensor data, and thorough validation procedures, developers can ensure their navigation systems will perform reliably in real-world applications. This simulation-based approach allows for safe, efficient testing of navigation capabilities before deployment on real robots."})]})}function _(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);