"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[7132],{3023(n,e,t){t.d(e,{R:()=>o,x:()=>r});var a=t(3696);const i={},s=a.createContext(i);function o(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(s.Provider,{value:e},n.children)}},3699(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>p});var a=t(2540),i=t(3023);const s={title:"Z-Axis Movement Navigation Examples",description:"Navigation examples and validation steps for humanoid robots handling Z-axis movement, stairs, and elevation changes using Nav2",sidebar_position:7,tags:["z-axis","elevation","stairs","navigation","humanoid","nav2"]},o="Z-Axis Movement Navigation Examples",r={id:"nav2-humanoid/z-axis-movement-navigation",title:"Z-Axis Movement Navigation Examples",description:"Navigation examples and validation steps for humanoid robots handling Z-axis movement, stairs, and elevation changes using Nav2",source:"@site/docs/nav2-humanoid/z-axis-movement-navigation.md",sourceDirName:"nav2-humanoid",slug:"/nav2-humanoid/z-axis-movement-navigation",permalink:"/docs/nav2-humanoid/z-axis-movement-navigation",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nav2-humanoid/z-axis-movement-navigation.md",tags:[{label:"z-axis",permalink:"/docs/tags/z-axis"},{label:"elevation",permalink:"/docs/tags/elevation"},{label:"stairs",permalink:"/docs/tags/stairs"},{label:"navigation",permalink:"/docs/tags/navigation"},{label:"humanoid",permalink:"/docs/tags/humanoid"},{label:"nav2",permalink:"/docs/tags/nav-2"}],version:"current",sidebarPosition:7,frontMatter:{title:"Z-Axis Movement Navigation Examples",description:"Navigation examples and validation steps for humanoid robots handling Z-axis movement, stairs, and elevation changes using Nav2",sidebar_position:7,tags:["z-axis","elevation","stairs","navigation","humanoid","nav2"]}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Z-Axis Navigation Fundamentals",id:"z-axis-navigation-fundamentals",level:2},{value:"Three-Dimensional Navigation Concepts",id:"three-dimensional-navigation-concepts",level:3},{value:"Z-Axis Navigation Challenges",id:"z-axis-navigation-challenges",level:3},{value:"Stair Navigation Implementation",id:"stair-navigation-implementation",level:2},{value:"Stair Detection and Classification",id:"stair-detection-and-classification",level:3},{value:"Stair Navigation Planner",id:"stair-navigation-planner",level:3},{value:"Ramp Navigation Implementation",id:"ramp-navigation-implementation",level:2},{value:"Ramp Detection and Navigation",id:"ramp-detection-and-navigation",level:3},{value:"Integration with Nav2",id:"integration-with-nav2",level:2},{value:"3D Costmap Layer",id:"3d-costmap-layer",level:3},{value:"Z-Axis Navigation Action Server",id:"z-axis-navigation-action-server",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:2},{value:"Z-Axis Navigation Validation",id:"z-axis-navigation-validation",level:3},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Z-Axis Navigation Configuration",id:"z-axis-navigation-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Z-Axis Navigation Best Practices",id:"z-axis-navigation-best-practices",level:3},{value:"Implementation Tips",id:"implementation-tips",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Z-Axis Navigation Issues",id:"common-z-axis-navigation-issues",level:3}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"z-axis-movement-navigation-examples",children:"Z-Axis Movement Navigation Examples"}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Z-axis movement navigation is a critical capability for humanoid robots, allowing them to navigate stairs, ramps, and elevation changes. Unlike wheeled robots, humanoid robots can handle discrete elevation changes and three-dimensional navigation. This document covers navigation examples and validation steps for Z-axis movement in humanoid robotics using Nav2."}),"\n",(0,a.jsx)(e.h2,{id:"z-axis-navigation-fundamentals",children:"Z-Axis Navigation Fundamentals"}),"\n",(0,a.jsx)(e.h3,{id:"three-dimensional-navigation-concepts",children:"Three-Dimensional Navigation Concepts"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots operate in 3D space with six degrees of freedom:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"X-axis"}),": Forward/backward movement"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Y-axis"}),": Left/right movement"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Z-axis"}),": Up/down movement (elevation)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Roll"}),": Rotation around X-axis (tilting forward/backward)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pitch"}),": Rotation around Y-axis (tilting left/right)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Yaw"}),": Rotation around Z-axis (turning)"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"For navigation, the Z-axis component introduces unique challenges:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stair navigation"}),": Discrete elevation changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Ramp navigation"}),": Continuous elevation changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step climbing"}),": Individual step navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance management"}),": Maintaining stability during elevation changes"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation-challenges",children:"Z-Axis Navigation Challenges"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Z-axis navigation challenges\nclass ZAxisNavigationChallenges:\n    def __init__(self):\n        self.challenges = {\n            "stair_detection": {\n                "description": "Identifying and classifying stairs",\n                "complexity": "High",\n                "solution_approach": "Computer vision and depth sensing"\n            },\n            "step_planning": {\n                "description": "Planning individual steps for elevation changes",\n                "complexity": "High",\n                "solution_approach": "Step-by-step path planning"\n            },\n            "balance_management": {\n                "description": "Maintaining balance during elevation changes",\n                "complexity": "Critical",\n                "solution_approach": "Balance control algorithms"\n            },\n            "terrain_classification": {\n                "description": "Identifying different elevation terrains",\n                "complexity": "Medium",\n                "solution_approach": "Sensor fusion and classification"\n            }\n        }\n\n    def get_challenge_complexity(self, challenge_name):\n        """\n        Get complexity rating for a specific challenge\n        """\n        return self.challenges.get(challenge_name, {}).get("complexity", "Unknown")\n\n    def get_solution_approach(self, challenge_name):\n        """\n        Get solution approach for a specific challenge\n        """\n        return self.challenges.get(challenge_name, {}).get("solution_approach", "No solution")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"stair-navigation-implementation",children:"Stair Navigation Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"stair-detection-and-classification",children:"Stair Detection and Classification"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Stair detection for navigation\nimport numpy as np\nimport cv2\nfrom sensor_msgs.msg import PointCloud2\nfrom geometry_msgs.msg import Point\n\nclass StairDetector:\n    def __init__(self):\n        self.min_step_height = 0.1  # meters\n        self.max_step_height = 0.2  # meters\n        self.step_depth = 0.3       # meters\n        self.stair_angle_threshold = 10.0  # degrees\n\n    def detect_stairs_from_pointcloud(self, pointcloud_msg):\n        """\n        Detect stairs from point cloud data\n        """\n        # Convert PointCloud2 to numpy array\n        points = self.pointcloud_to_array(pointcloud_msg)\n\n        # Segment ground plane to identify elevation changes\n        ground_points, elevated_points = self.segment_ground_plane(points)\n\n        # Identify potential stair regions\n        stair_regions = self.identify_stair_regions(elevated_points, ground_points)\n\n        # Validate stair regions\n        validated_stairs = []\n        for region in stair_regions:\n            if self.validate_stair_region(region):\n                validated_stairs.append(region)\n\n        return validated_stairs\n\n    def segment_ground_plane(self, points):\n        """\n        Segment ground plane from point cloud using RANSAC\n        """\n        from sklearn.linear_model import RANSACRegressor\n\n        # Prepare data for RANSAC\n        X = points[:, [0, 1]]  # x, y coordinates\n        y = points[:, 2]       # z coordinates (height)\n\n        # Apply RANSAC to find ground plane\n        ransac = RANSACRegressor(random_state=42)\n        ransac.fit(X, y)\n\n        # Identify inliers (ground points) and outliers (elevated points)\n        inlier_mask = ransac.inlier_mask_\n\n        ground_points = points[inlier_mask]\n        elevated_points = points[~inlier_mask]\n\n        return ground_points, elevated_points\n\n    def identify_stair_regions(self, elevated_points, ground_points):\n        """\n        Identify potential stair regions in elevated points\n        """\n        stair_regions = []\n\n        # Group elevated points by elevation levels\n        elevation_levels = self.group_by_elevation(elevated_points)\n\n        # Check for regular elevation changes (indicating stairs)\n        for i in range(len(elevation_levels) - 1):\n            current_level = elevation_levels[i]\n            next_level = elevation_levels[i + 1]\n\n            height_diff = next_level[\'elevation\'] - current_level[\'elevation\']\n\n            # Check if height difference matches stair step height\n            if self.min_step_height <= height_diff <= self.max_step_height:\n                # Check if the area has stair-like characteristics\n                if self.is_stair_like_area(current_level, next_level):\n                    stair_regions.append({\n                        \'bottom_level\': current_level,\n                        \'top_level\': next_level,\n                        \'height_diff\': height_diff,\n                        \'type\': \'stairs\'\n                    })\n\n        return stair_regions\n\n    def validate_stair_region(self, stair_region):\n        """\n        Validate if detected region is actually stairs\n        """\n        # Check dimensions and regularity\n        if (stair_region[\'height_diff\'] >= self.min_step_height and\n            stair_region[\'height_diff\'] <= self.max_step_height):\n\n            # Additional validation checks\n            return True\n\n        return False\n\n    def group_by_elevation(self, points):\n        """\n        Group points by elevation levels\n        """\n        # Sort points by elevation\n        sorted_points = points[points[:, 2].argsort()]\n\n        # Group points with similar elevations\n        elevation_groups = []\n        current_group = []\n        current_elevation = sorted_points[0][2]\n\n        for point in sorted_points:\n            if abs(point[2] - current_elevation) < 0.05:  # 5cm tolerance\n                current_group.append(point)\n            else:\n                if current_group:\n                    elevation_groups.append({\n                        \'points\': np.array(current_group),\n                        \'elevation\': current_elevation,\n                        \'center\': np.mean(current_group, axis=0)\n                    })\n                current_group = [point]\n                current_elevation = point[2]\n\n        if current_group:\n            elevation_groups.append({\n                \'points\': np.array(current_group),\n                \'elevation\': current_elevation,\n                \'center\': np.mean(current_group, axis=0)\n            })\n\n        return elevation_groups\n\n    def is_stair_like_area(self, level1, level2):\n        """\n        Check if area has stair-like characteristics\n        """\n        # Check for regular spacing and dimensions\n        # This is a simplified check - real implementation would be more complex\n        return True\n'})}),"\n",(0,a.jsx)(e.h3,{id:"stair-navigation-planner",children:"Stair Navigation Planner"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Stair navigation planning\nclass StairNavigationPlanner:\n    def __init__(self):\n        self.step_height = 0.15  # meters\n        self.step_depth = 0.30   # meters\n        self.step_width = 0.80   # meters\n        self.foot_clearance = 0.05  # meters\n\n    def plan_stair_navigation(self, start_pose, end_pose, stair_info):\n        """\n        Plan navigation through stairs\n        """\n        navigation_steps = []\n\n        # Calculate stair climb path\n        stair_path = self.calculate_stair_path(start_pose, end_pose, stair_info)\n\n        # Generate footstep plan\n        footsteps = self.generate_footsteps_for_stairs(stair_path, stair_info)\n\n        # Add approach and departure steps\n        approach_steps = self.generate_approach_steps(start_pose, stair_path[0])\n        departure_steps = self.generate_departure_steps(stair_path[-1], end_pose)\n\n        navigation_steps.extend(approach_steps)\n        navigation_steps.extend(footsteps)\n        navigation_steps.extend(departure_steps)\n\n        return navigation_steps\n\n    def calculate_stair_path(self, start_pose, end_pose, stair_info):\n        """\n        Calculate path through stairs\n        """\n        path = []\n\n        # Calculate number of steps needed\n        height_diff = end_pose.position.z - start_pose.position.z\n        num_steps = int(abs(height_diff) / self.step_height)\n\n        # Generate intermediate poses for each step\n        for i in range(1, num_steps + 1):\n            step_pose = self.interpolate_stair_pose(\n                start_pose, end_pose, i, num_steps\n            )\n            path.append(step_pose)\n\n        return path\n\n    def generate_footsteps_for_stairs(self, stair_path, stair_info):\n        """\n        Generate footstep plan for stair navigation\n        """\n        footsteps = []\n        support_foot = "left"  # Start with left foot as support\n\n        for i, step_pose in enumerate(stair_path):\n            # Calculate foot placement for this step\n            if support_foot == "left":\n                # Right foot moves up\n                right_foot_pose = self.calculate_right_foot_stair_pose(\n                    step_pose, support_foot\n                )\n                footsteps.append(("right", right_foot_pose))\n            else:\n                # Left foot moves up\n                left_foot_pose = self.calculate_left_foot_stair_pose(\n                    step_pose, support_foot\n                )\n                footsteps.append(("left", left_foot_pose))\n\n            # Alternate support foot\n            support_foot = "right" if support_foot == "left" else "left"\n\n        return footsteps\n\n    def interpolate_stair_pose(self, start_pose, end_pose, step_num, total_steps):\n        """\n        Interpolate pose for a specific stair step\n        """\n        from geometry_msgs.msg import Pose\n        interpolated_pose = Pose()\n\n        # Linear interpolation for X, Y\n        ratio = step_num / total_steps\n        interpolated_pose.position.x = start_pose.position.x + \\\n            (end_pose.position.x - start_pose.position.x) * ratio\n        interpolated_pose.position.y = start_pose.position.y + \\\n            (end_pose.position.y - start_pose.position.y) * ratio\n\n        # Step-wise interpolation for Z (stair steps)\n        step_height = self.step_height\n        interpolated_pose.position.z = start_pose.position.z + step_height * step_num\n\n        # Maintain orientation\n        interpolated_pose.orientation = start_pose.orientation\n\n        return interpolated_pose\n\n    def calculate_right_foot_stair_pose(self, target_pose, support_foot):\n        """\n        Calculate right foot pose for stair climbing\n        """\n        from geometry_msgs.msg import Pose\n        foot_pose = Pose()\n\n        # Position foot for stair climbing\n        foot_pose.position.x = target_pose.position.x\n        foot_pose.position.y = target_pose.position.y - 0.1  # Slightly inward\n        foot_pose.position.z = target_pose.position.z + self.foot_clearance\n\n        foot_pose.orientation = target_pose.orientation\n\n        return foot_pose\n\n    def generate_approach_steps(self, start_pose, stair_start_pose):\n        """\n        Generate approach steps before stairs\n        """\n        approach_steps = []\n\n        # Calculate approach path\n        approach_path = self.calculate_approach_path(start_pose, stair_start_pose)\n\n        # Convert to footsteps\n        for pose in approach_path:\n            approach_steps.append(("approach", pose))\n\n        return approach_steps\n\n    def generate_departure_steps(self, stair_end_pose, end_pose):\n        """\n        Generate departure steps after stairs\n        """\n        departure_steps = []\n\n        # Calculate departure path\n        departure_path = self.calculate_departure_path(stair_end_pose, end_pose)\n\n        # Convert to footsteps\n        for pose in departure_path:\n            departure_steps.append(("departure", pose))\n\n        return departure_steps\n'})}),"\n",(0,a.jsx)(e.h2,{id:"ramp-navigation-implementation",children:"Ramp Navigation Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"ramp-detection-and-navigation",children:"Ramp Detection and Navigation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Ramp navigation\nclass RampNavigation:\n    def __init__(self):\n        self.max_ramp_angle = 15.0  # degrees\n        self.ramp_step_size = 0.2   # meters\n\n    def detect_ramps(self, elevation_data):\n        """\n        Detect ramps in elevation data\n        """\n        ramps = []\n\n        # Calculate elevation gradients\n        gradients = self.calculate_elevation_gradients(elevation_data)\n\n        # Identify regions with consistent moderate slopes\n        for i, gradient in enumerate(gradients):\n            if self.is_ramp_gradient(gradient):\n                ramp = self.extract_ramp_info(elevation_data, i)\n                ramps.append(ramp)\n\n        return ramps\n\n    def calculate_elevation_gradients(self, elevation_data):\n        """\n        Calculate elevation gradients from elevation data\n        """\n        gradients = []\n\n        for i in range(1, len(elevation_data)):\n            dx = elevation_data[i].x - elevation_data[i-1].x\n            dz = elevation_data[i].z - elevation_data[i-1].z\n            gradient = np.arctan2(abs(dz), abs(dx)) * 180 / np.pi  # Convert to degrees\n            gradients.append(gradient)\n\n        return gradients\n\n    def is_ramp_gradient(self, gradient):\n        """\n        Check if gradient indicates a ramp\n        """\n        return 2.0 <= gradient <= self.max_ramp_angle  # Between 2 and 15 degrees\n\n    def plan_ramp_navigation(self, start_pose, end_pose, ramp_info):\n        """\n        Plan navigation through ramp\n        """\n        # Break ramp into manageable segments\n        ramp_segments = self.divide_ramp_into_segments(start_pose, end_pose, ramp_info)\n\n        # Plan footsteps for each segment\n        footsteps = []\n        for segment in ramp_segments:\n            segment_footsteps = self.plan_segment_footsteps(segment)\n            footsteps.extend(segment_footsteps)\n\n        return footsteps\n\n    def divide_ramp_into_segments(self, start_pose, end_pose, ramp_info):\n        """\n        Divide ramp into smaller navigable segments\n        """\n        segments = []\n\n        # Calculate total distance along ramp\n        total_distance = self.calculate_ramp_distance(start_pose, end_pose)\n\n        # Divide into segments based on step size\n        num_segments = int(total_distance / self.ramp_step_size)\n\n        for i in range(num_segments):\n            segment_start = self.interpolate_pose(\n                start_pose, end_pose, i / num_segments\n            )\n            segment_end = self.interpolate_pose(\n                start_pose, end_pose, (i + 1) / num_segments\n            )\n\n            segments.append({\n                \'start\': segment_start,\n                \'end\': segment_end,\n                \'segment_number\': i\n            })\n\n        return segments\n\n    def plan_segment_footsteps(self, segment):\n        """\n        Plan footsteps for a ramp segment\n        """\n        footsteps = []\n\n        # Calculate required steps for this segment\n        dx = segment[\'end\'].position.x - segment[\'start\'].position.x\n        dy = segment[\'end\'].position.y - segment[\'start\'].position.y\n        dz = segment[\'end\'].position.z - segment[\'start\'].position.z\n\n        distance_2d = np.sqrt(dx**2 + dy**2)\n\n        # Number of steps needed\n        num_steps = max(1, int(distance_2d / 0.3))  # 30cm per step\n\n        for i in range(num_steps):\n            step_ratio = i / num_steps\n            step_pose = self.interpolate_pose_with_elevation(\n                segment[\'start\'], segment[\'end\'], step_ratio\n            )\n\n            footsteps.append(step_pose)\n\n        return footsteps\n\n    def interpolate_pose_with_elevation(self, start_pose, end_pose, ratio):\n        """\n        Interpolate pose considering elevation changes\n        """\n        from geometry_msgs.msg import Pose\n        interpolated_pose = Pose()\n\n        # Interpolate X, Y, Z positions\n        interpolated_pose.position.x = start_pose.position.x + \\\n            (end_pose.position.x - start_pose.position.x) * ratio\n        interpolated_pose.position.y = start_pose.position.y + \\\n            (end_pose.position.y - start_pose.position.y) * ratio\n        interpolated_pose.position.z = start_pose.position.z + \\\n            (end_pose.position.z - start_pose.position.z) * ratio\n\n        # Interpolate orientation\n        interpolated_pose.orientation = self.interpolate_orientation(\n            start_pose.orientation, end_pose.orientation, ratio\n        )\n\n        return interpolated_pose\n'})}),"\n",(0,a.jsx)(e.h2,{id:"integration-with-nav2",children:"Integration with Nav2"}),"\n",(0,a.jsx)(e.h3,{id:"3d-costmap-layer",children:"3D Costmap Layer"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# 3D costmap for elevation-aware navigation\nfrom nav2_costmap_2d.layers import CostmapLayer\nfrom nav2_costmap_2d import Costmap2D\nimport numpy as np\n\nclass ZAxisCostmapLayer(CostmapLayer):\n    def __init__(self, name, costmap, nh):\n        super().__init__()\n        self.layer_name = name\n        self.costmap = costmap\n        self.nh = nh\n\n        # Z-axis specific parameters\n        self.max_step_height = self.nh.get_parameter(\'max_step_height\', 0.2)\n        self.min_traversable_slope = self.nh.get_parameter(\'min_traversable_slope\', 5.0)\n        self.max_traversable_slope = self.nh.get_parameter(\'max_traversable_slope\', 15.0)\n\n    def updateBounds(self, robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y):\n        """\n        Update bounds considering Z-axis constraints\n        """\n        # Call parent method\n        self.updateBoundsFromArea(min_x, min_y, max_x, max_y)\n\n        # Apply Z-axis constraints\n        self.apply_z_axis_constraints(robot_x, robot_y, min_x, min_y, max_x, max_y)\n\n    def apply_z_axis_constraints(self, robot_x, robot_y, min_x, min_y, max_x, max_y):\n        """\n        Apply Z-axis constraints to costmap\n        """\n        for x in range(int(min_x), int(max_x)):\n            for y in range(int(min_y), int(max_y)):\n                world_x, world_y = self.costmap.getOriginX() + x, self.costmap.getOriginY() + y\n\n                # Get elevation data at this location\n                elevation = self.get_elevation_at(world_x, world_y)\n\n                # Check if elevation change is within robot capabilities\n                robot_elevation = self.get_robot_elevation()\n                elevation_diff = abs(elevation - robot_elevation)\n\n                if elevation_diff > self.max_step_height:\n                    # Mark as lethal obstacle if elevation change too large\n                    self.setCost(x, y, 254)  # LETHAL_OBSTACLE\n\n    def updateCosts(self, master_grid, min_i, min_j, max_i, max_j):\n        """\n        Update costs considering Z-axis factors\n        """\n        for i in range(min_i, max_i):\n            for j in range(min_j, max_j):\n                cost = master_grid.getCost(i, j)\n\n                if cost >= 0 and cost < 253:  # Not unknown or lethal\n                    # Apply Z-axis specific costs\n                    z_cost = self.calculate_z_axis_cost(i, j)\n                    final_cost = self.combine_costs(cost, z_cost)\n                    master_grid.setCost(i, j, final_cost)\n\n    def calculate_z_axis_cost(self, i, j):\n        """\n        Calculate Z-axis specific cost for a cell\n        """\n        world_x = self.costmap.getOriginX() + i\n        world_y = self.costmap.getOriginY() + j\n\n        # Get elevation and slope data\n        elevation = self.get_elevation_at(world_x, world_y)\n        slope = self.get_slope_at(world_x, world_y)\n\n        # Calculate cost based on slope traversability\n        if slope < self.min_traversable_slope:\n            return 0  # Easy to traverse\n        elif slope > self.max_traversable_slope:\n            return 254  # Too steep, lethal obstacle\n        else:\n            # Cost increases with slope\n            normalized_slope = (slope - self.min_traversable_slope) / \\\n                              (self.max_traversable_slope - self.min_traversable_slope)\n            return int(normalized_slope * 200)  # Scale to cost range\n\n    def get_elevation_at(self, x, y):\n        """\n        Get elevation at specific coordinates\n        """\n        # Implementation would interface with elevation map\n        return 0.0  # Placeholder\n\n    def get_slope_at(self, x, y):\n        """\n        Get slope at specific coordinates\n        """\n        # Implementation would calculate local slope\n        return 0.0  # Placeholder\n\n    def get_robot_elevation(self):\n        """\n        Get current robot elevation\n        """\n        # Implementation would get from robot state\n        return 0.0  # Placeholder\n'})}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation-action-server",children:"Z-Axis Navigation Action Server"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Z-axis navigation action server\nimport rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom nav2_msgs.action import NavigateToPose\nfrom std_msgs.msg import Bool\n\nclass ZAxisNavigationServer(Node):\n    def __init__(self):\n        super().__init__(\'z_axis_navigation_server\')\n\n        # Action server\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            \'z_axis_navigate_to_pose\',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Publishers\n        self.navigation_status_pub = self.create_publisher(\n            Bool, \'/z_axis_navigation_status\', 10\n        )\n\n        # Navigation components\n        self.stair_planner = StairNavigationPlanner()\n        self.ramp_navigator = RampNavigation()\n        self.balance_monitor = self.create_subscription(\n            Bool, \'/balance_status\', self.balance_callback, 10\n        )\n\n        self.current_balance = True\n        self.navigation_in_progress = False\n\n    def goal_callback(self, goal_request):\n        """\n        Handle navigation goal request\n        """\n        # Check if goal has Z-axis component\n        z_difference = abs(goal_request.pose.pose.position.z - self.get_robot_z_position())\n\n        if z_difference > 0.1:  # If significant Z difference\n            return GoalResponse.ACCEPT\n        else:\n            return GoalResponse.REJECT\n\n    def cancel_callback(self, goal_handle):\n        """\n        Handle navigation cancel request\n        """\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """\n        Execute navigation goal\n        """\n        self.navigation_in_progress = True\n\n        try:\n            # Get goal pose\n            goal_pose = goal_handle.request.pose\n\n            # Analyze Z-axis requirements\n            z_analysis = self.analyze_z_axis_requirements(goal_pose)\n\n            # Plan navigation based on Z-axis analysis\n            if z_analysis[\'terrain_type\'] == \'stairs\':\n                navigation_plan = self.stair_planner.plan_stair_navigation(\n                    self.get_current_pose(), goal_pose, z_analysis[\'terrain_info\']\n                )\n            elif z_analysis[\'terrain_type\'] == \'ramp\':\n                navigation_plan = self.ramp_navigator.plan_ramp_navigation(\n                    self.get_current_pose(), goal_pose, z_analysis[\'terrain_info\']\n                )\n            else:\n                # Standard 2D navigation\n                navigation_plan = self.plan_2d_navigation(\n                    self.get_current_pose(), goal_pose\n                )\n\n            # Execute navigation plan\n            success = self.execute_navigation_plan(navigation_plan)\n\n            # Create result\n            result = NavigateToPose.Result()\n            result.result_code = NavigateToPose.Result.SUCCEEDED if success else NavigateToPose.Result.FAILED\n\n            if success:\n                goal_handle.succeed()\n            else:\n                goal_handle.abort()\n\n            return result\n\n        except Exception as e:\n            self.get_logger().error(f\'Navigation execution failed: {e}\')\n            goal_handle.abort()\n\n            result = NavigateToPose.Result()\n            result.result_code = NavigateToPose.Result.FAILED\n            return result\n        finally:\n            self.navigation_in_progress = False\n\n    def analyze_z_axis_requirements(self, goal_pose):\n        """\n        Analyze Z-axis requirements for navigation\n        """\n        current_z = self.get_robot_z_position()\n        goal_z = goal_pose.pose.position.z\n        z_difference = abs(goal_z - current_z)\n\n        # Detect stairs, ramps, or other elevation changes\n        terrain_type = self.detect_terrain_type(current_z, goal_z)\n\n        return {\n            \'current_z\': current_z,\n            \'goal_z\': goal_z,\n            \'z_difference\': z_difference,\n            \'terrain_type\': terrain_type,\n            \'terrain_info\': self.get_terrain_info(current_z, goal_z)\n        }\n\n    def detect_terrain_type(self, start_z, end_z):\n        """\n        Detect terrain type based on elevation change\n        """\n        z_diff = abs(end_z - start_z)\n\n        if z_diff < 0.1:\n            return \'flat\'\n        elif 0.1 <= z_diff <= 0.5:\n            # Check for discrete steps (stairs) vs continuous slope (ramp)\n            return self.classify_elevation_change(start_z, end_z)\n        else:\n            return \'elevation_change\'\n\n    def classify_elevation_change(self, start_z, end_z):\n        """\n        Classify elevation change as stairs or ramp\n        """\n        # Implementation would analyze intermediate elevation data\n        # For simplicity, assume stairs for discrete changes\n        return \'stairs\'\n\n    def execute_navigation_plan(self, plan):\n        """\n        Execute navigation plan\n        """\n        for step in plan:\n            if not self.current_balance:\n                self.get_logger().error(\'Balance compromised, stopping navigation\')\n                return False\n\n            if not self.navigation_in_progress:\n                return False\n\n            # Execute step\n            success = self.execute_navigation_step(step)\n            if not success:\n                return False\n\n            # Small delay between steps for humanoid robots\n            time.sleep(0.1)\n\n        return True\n\n    def balance_callback(self, msg):\n        """\n        Update balance status\n        """\n        self.current_balance = msg.data\n\n    def get_robot_z_position(self):\n        """\n        Get current robot Z position\n        """\n        # Implementation would get from robot state\n        return 0.0\n\n    def get_current_pose(self):\n        """\n        Get current robot pose\n        """\n        # Implementation would get from localization system\n        from geometry_msgs.msg import PoseStamped\n        pose = PoseStamped()\n        return pose\n'})}),"\n",(0,a.jsx)(e.h2,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation-validation",children:"Z-Axis Navigation Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Z-axis navigation validation\nimport unittest\nimport numpy as np\n\nclass TestZAxisNavigation(unittest.TestCase):\n    def setUp(self):\n        self.stair_detector = StairDetector()\n        self.stair_planner = StairNavigationPlanner()\n        self.ramp_navigator = RampNavigation()\n\n    def test_stair_detection(self):\n        """\n        Test stair detection functionality\n        """\n        # Create mock point cloud data with stairs\n        stair_points = self.create_stair_pointcloud()\n\n        # Detect stairs\n        detected_stairs = self.stair_detector.detect_stairs_from_pointcloud(stair_points)\n\n        # Verify detection\n        self.assertGreater(len(detected_stairs), 0, "Stairs should be detected")\n\n        # Verify stair properties\n        for stair in detected_stairs:\n            self.assertGreaterEqual(stair[\'height_diff\'], 0.1, "Stair height should be reasonable")\n            self.assertLessEqual(stair[\'height_diff\'], 0.2, "Stair height should be reasonable")\n\n    def test_stair_navigation_planning(self):\n        """\n        Test stair navigation planning\n        """\n        from geometry_msgs.msg import Pose\n\n        # Create start and end poses with Z difference\n        start_pose = Pose()\n        start_pose.position.x = 0.0\n        start_pose.position.y = 0.0\n        start_pose.position.z = 0.0\n\n        end_pose = Pose()\n        end_pose.position.x = 2.0\n        end_pose.position.y = 0.0\n        end_pose.position.z = 0.3  # 30cm elevation change\n\n        # Create stair info\n        stair_info = {\n            \'type\': \'stairs\',\n            \'height_diff\': 0.3,\n            \'num_steps\': 2\n        }\n\n        # Plan navigation\n        navigation_plan = self.stair_planner.plan_stair_navigation(\n            start_pose, end_pose, stair_info\n        )\n\n        # Verify plan\n        self.assertGreater(len(navigation_plan), 0, "Navigation plan should be created")\n\n        # Check that plan includes Z-axis changes\n        z_positions = [step[1].position.z for step in navigation_plan if len(step) > 1 and hasattr(step[1], \'position\')]\n        self.assertTrue(any(z > 0.0 for z in z_positions), "Plan should include Z-axis movement")\n\n    def test_ramp_navigation(self):\n        """\n        Test ramp navigation\n        """\n        from geometry_msgs.msg import Pose\n\n        # Create start and end poses for ramp\n        start_pose = Pose()\n        start_pose.position.x = 0.0\n        start_pose.position.y = 0.0\n        start_pose.position.z = 0.0\n\n        end_pose = Pose()\n        end_pose.position.x = 3.0\n        end_pose.position.y = 0.0\n        end_pose.position.z = 0.5  # Gentle slope\n\n        # Create ramp info\n        ramp_info = {\n            \'type\': \'ramp\',\n            \'slope\': 10.0  # degrees\n        }\n\n        # Plan ramp navigation\n        footsteps = self.ramp_navigator.plan_ramp_navigation(start_pose, end_pose, ramp_info)\n\n        # Verify plan\n        self.assertGreater(len(footsteps), 0, "Ramp navigation plan should be created")\n\n        # Check gradual Z changes\n        if len(footsteps) > 1:\n            z_diffs = [\n                footsteps[i+1].position.z - footsteps[i].position.z\n                for i in range(len(footsteps)-1)\n            ]\n            avg_z_diff = np.mean([abs(diff) for diff in z_diffs])\n            self.assertLess(avg_z_diff, 0.1, "Z changes should be gradual for ramps")\n\n    def create_stair_pointcloud(self):\n        """\n        Create mock point cloud data representing stairs\n        """\n        # Create points representing two steps\n        points = []\n\n        # First step (0.15m high, 0.3m deep)\n        for x in np.arange(0, 0.3, 0.05):\n            for y in np.arange(-0.4, 0.4, 0.05):\n                points.append([x, y, 0.15])\n\n        # Second step (0.30m high, 0.3m deep)\n        for x in np.arange(0.3, 0.6, 0.05):\n            for y in np.arange(-0.4, 0.4, 0.05):\n                points.append([x, y, 0.30])\n\n        # Convert to PointCloud2 format (simplified)\n        return np.array(points)\n\nif __name__ == \'__main__\':\n    unittest.main()\n'})}),"\n",(0,a.jsx)(e.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation-configuration",children:"Z-Axis Navigation Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'# Z-axis navigation configuration\nz_axis_navigation:\n  ros__parameters:\n    # Stair navigation parameters\n    stair:\n      max_step_height: 0.2  # meters\n      min_step_height: 0.1  # meters\n      step_depth: 0.3       # meters\n      step_width: 0.8       # meters\n      foot_clearance: 0.05  # meters\n\n    # Ramp navigation parameters\n    ramp:\n      max_slope_angle: 15.0  # degrees\n      min_slope_angle: 2.0   # degrees\n      step_size: 0.2         # meters\n\n    # General Z-axis parameters\n    z_axis:\n      enable_3d_navigation: true\n      elevation_tolerance: 0.05  # meters\n      z_threshold_for_3d: 0.1    # minimum Z difference to trigger 3D nav\n\n    # Costmap parameters\n    costmap:\n      max_step_height: 0.2\n      min_traversable_slope: 5.0\n      max_traversable_slope: 15.0\n\n# Integration with Nav2 costmap\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: false\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05\n      # Z-axis costmap layer\n      plugins: [\n        "z_axis_layer",\n        "static_layer",\n        "obstacle_layer",\n        "inflation_layer"\n      ]\n      z_axis_layer:\n        plugin: "z_axis_costmap_layer.ZAxisCostmapLayer"\n        enabled: true\n        max_step_height: 0.2\n        min_traversable_slope: 5.0\n        max_traversable_slope: 15.0\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"z-axis-navigation-best-practices",children:"Z-Axis Navigation Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Progressive Testing"}),": Start with simple elevation changes and increase complexity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety First"}),": Always prioritize balance and safety over navigation speed"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Fusion"}),": Use multiple sensors for reliable elevation detection"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step Validation"}),": Validate each step before execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery Planning"}),": Plan recovery behaviors for failed elevation navigation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Modular Design"}),": Separate stair, ramp, and general Z-axis navigation logic"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter Tuning"}),": Carefully tune parameters for your specific robot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simulation Testing"}),": Extensively test in simulation before real robot deployment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Continuous Monitoring"}),": Monitor balance and stability throughout navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fallback Strategies"}),": Implement fallback navigation for challenging terrain"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(e.h3,{id:"common-z-axis-navigation-issues",children:"Common Z-Axis Navigation Issues"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'# Troubleshooting guide for Z-axis navigation\ntroubleshooting:\n  common_issues:\n    - issue: "Stair detection failures"\n      symptoms:\n        - "Robot doesn\'t recognize stairs"\n        - "Attempts to navigate stairs as flat ground"\n      causes:\n        - "Insufficient sensor resolution"\n        - "Poor lighting conditions"\n        - "Sensor noise"\n      solutions:\n        - "Improve sensor quality and resolution"\n        - "Use multiple sensors for redundancy"\n        - "Apply sensor fusion techniques"\n\n    - issue: "Balance loss during elevation changes"\n      symptoms:\n        - "Robot falls during stair climbing"\n        - "Frequent balance recovery"\n      causes:\n        - "Step timing too aggressive"\n        - "Balance controller not tuned"\n        - "Gait parameters incorrect"\n      solutions:\n        - "Slow down step execution timing"\n        - "Tune balance control parameters"\n        - "Improve gait planning"\n\n    - issue: "Inefficient Z-axis navigation"\n      symptoms:\n        - "Long navigation times for elevation changes"\n        - "Excessive computation during planning"\n      causes:\n        - "Complex planning algorithms"\n        - "Inefficient path optimization"\n      solutions:\n        - "Simplify planning where possible"\n        - "Use pre-computed navigation maps"\n        - "Optimize algorithms for real-time performance"\n'})}),"\n",(0,a.jsx)(e.p,{children:"This comprehensive guide provides examples and validation steps for implementing Z-axis movement navigation in humanoid robots using Nav2, covering stairs, ramps, and general elevation changes."})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(_,{...n})}):_(n)}}}]);