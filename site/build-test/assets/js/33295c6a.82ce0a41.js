"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[6393],{3023(n,e,i){i.d(e,{R:()=>r,x:()=>l});var o=i(3696);const t={},s=o.createContext(t);function r(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(s.Provider,{value:e},n.children)}},8037(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var o=i(2540),t=i(3023);const s={title:"Gazebo Physics Simulation",sidebar_position:1,description:"Learn how to create physics-based simulations in Gazebo for humanoid robots with ROS 2 integration"},r="Gazebo Physics Simulation for Humanoid Robots",l={id:"module2/gazebo-physics",title:"Gazebo Physics Simulation",description:"Learn how to create physics-based simulations in Gazebo for humanoid robots with ROS 2 integration",source:"@site/docs/module2/gazebo-physics.md",sourceDirName:"module2",slug:"/module2/gazebo-physics",permalink:"/docs/module2/gazebo-physics",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module2/gazebo-physics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Gazebo Physics Simulation",sidebar_position:1,description:"Learn how to create physics-based simulations in Gazebo for humanoid robots with ROS 2 integration"},sidebar:"tutorialSidebar",previous:{title:"ROS 2 Fundamentals for Humanoids",permalink:"/docs/module1/ros2-fundamentals"},next:{title:"Simulated Sensors",permalink:"/docs/module2/simulated-sensors"}},a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Gazebo Physics",id:"introduction-to-gazebo-physics",level:2},{value:"Understanding Physics Engines",id:"understanding-physics-engines",level:2},{value:"Available Physics Engines",id:"available-physics-engines",level:3},{value:"Physics Parameters",id:"physics-parameters",level:3},{value:"Creating World Files",id:"creating-world-files",level:2},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Physics Configuration",id:"physics-configuration",level:3},{value:"Humanoid Robot Model Integration",id:"humanoid-robot-model-integration",level:2},{value:"URDF Integration",id:"urdf-integration",level:3},{value:"Joint Configuration",id:"joint-configuration",level:3},{value:"Launching Physics Simulations",id:"launching-physics-simulations",level:2},{value:"ROS 2 Launch Files",id:"ros-2-launch-files",level:3},{value:"Running the Simulation",id:"running-the-simulation",level:3},{value:"Controlling Robot Joints",id:"controlling-robot-joints",level:2},{value:"Joint State Publisher",id:"joint-state-publisher",level:3},{value:"Trajectory Control",id:"trajectory-control",level:3},{value:"Testing Physics Simulation",id:"testing-physics-simulation",level:2},{value:"Basic Movement Test",id:"basic-movement-test",level:3},{value:"Environmental Interaction Test",id:"environmental-interaction-test",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Physics Fidelity vs Performance",id:"physics-fidelity-vs-performance",level:3},{value:"Real-Time Factor",id:"real-time-factor",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Robot Falling Through Ground",id:"robot-falling-through-ground",level:3},{value:"Unstable Joint Movements",id:"unstable-joint-movements",level:3},{value:"Slow Simulation Performance",id:"slow-simulation-performance",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Model Design",id:"model-design",level:3},{value:"Simulation Setup",id:"simulation-setup",level:3},{value:"Summary",id:"summary",level:2},{value:"Physics Simulation Concepts and Code Examples",id:"physics-simulation-concepts-and-code-examples",level:2},{value:"Joint Control Implementation",id:"joint-control-implementation",level:3},{value:"Physics Configuration Best Practices",id:"physics-configuration-best-practices",level:3},{value:"Launch File Configuration",id:"launch-file-configuration",level:3},{value:"Exercises",id:"exercises",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"gazebo-physics-simulation-for-humanoid-robots",children:"Gazebo Physics Simulation for Humanoid Robots"}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the fundamentals of physics simulation in Gazebo"}),"\n",(0,o.jsx)(e.li,{children:"Create world files with proper physics properties for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Configure physics engines and parameters for realistic simulation"}),"\n",(0,o.jsx)(e.li,{children:"Launch and run basic physics simulations with humanoid models"}),"\n",(0,o.jsx)(e.li,{children:"Control robot joints and observe physics interactions"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-gazebo-physics",children:"Introduction to Gazebo Physics"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo is a powerful 3D simulation environment that provides robust physics simulation capabilities. For humanoid robotics, Gazebo enables realistic modeling of physical interactions between robots and their environment. This chapter will cover how to set up and configure physics simulations for humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"understanding-physics-engines",children:"Understanding Physics Engines"}),"\n",(0,o.jsx)(e.h3,{id:"available-physics-engines",children:"Available Physics Engines"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different characteristics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Default engine, good balance of performance and accuracy"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bullet"}),": High-performance engine, good for real-time simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Advanced engine with constraint-based solver"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"physics-parameters",children:"Physics Parameters"}),"\n",(0,o.jsx)(e.p,{children:"Key physics parameters that affect simulation behavior:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gravity"}),": Typically set to Earth's gravity (-9.81 m/s\xb2 in Z direction)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Time Step"}),": Simulation time increment (smaller = more accurate but slower)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real Time Factor"}),": Target simulation speed (1.0 = real-time)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Max Contacts"}),": Maximum contacts between objects"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"creating-world-files",children:"Creating World Files"}),"\n",(0,o.jsx)(e.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,o.jsx)(e.p,{children:"A Gazebo world file is an SDF (Simulation Description Format) file that defines the simulation environment:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Include models --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Add your humanoid robot --\x3e\n    <include>\n      <uri>file://models/humanoid/basic_humanoid.urdf</uri>\n      <pose>0 0 1 0 0 0</pose>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,o.jsx)(e.p,{children:"The physics section defines how the simulation behaves:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">\n  \x3c!-- Gravity vector (x, y, z) --\x3e\n  <gravity>0 0 -9.8</gravity>\n\n  \x3c!-- Time step for simulation (seconds) --\x3e\n  <max_step_size>0.001</max_step_size>\n\n  \x3c!-- Target real-time factor --\x3e\n  <real_time_factor>1.0</real_time_factor>\n\n  \x3c!-- Update rate (Hz) --\x3e\n  <real_time_update_rate>1000.0</real_time_update_rate>\n\n  \x3c!-- Solver parameters --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>10</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-robot-model-integration",children:"Humanoid Robot Model Integration"}),"\n",(0,o.jsx)(e.h3,{id:"urdf-integration",children:"URDF Integration"}),"\n",(0,o.jsx)(e.p,{children:"To integrate a humanoid robot model into Gazebo, you need to ensure your URDF is compatible:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<robot name="basic_humanoid">\n  \x3c!-- Links with physical properties --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.3 0.3 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 0.8"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.3 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints with proper limits --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.3"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"joint-configuration",children:"Joint Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Proper joint configuration is crucial for realistic physics simulation:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Revolute joints"}),": For rotational movement with limits"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Prismatic joints"}),": For linear movement with limits"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fixed joints"}),": For permanent connections"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Continuous joints"}),": For unlimited rotation (use carefully)"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"launching-physics-simulations",children:"Launching Physics Simulations"}),"\n",(0,o.jsx)(e.h3,{id:"ros-2-launch-files",children:"ROS 2 Launch Files"}),"\n",(0,o.jsx)(e.p,{children:"Create launch files to easily start your physics simulations:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.actions import ExecuteProcess\nimport os\n\n\ndef generate_launch_description():\n    \"\"\"Launch Gazebo with physics simulation.\"\"\"\n\n    # World file argument\n    world_arg = DeclareLaunchArgument(\n        'world',\n        default_value='basic_humanoid.sdf',\n        description='Choose one of the world files from `/examples/gazebo/worlds`'\n    )\n\n    # Get world file path\n    world_path = os.path.join(\n        get_package_share_directory('examples_gazebo'),\n        'worlds',\n        LaunchConfiguration('world')\n    )\n\n    # Launch Gazebo\n    gazebo = ExecuteProcess(\n        cmd=['gz', 'sim', '-r', world_path],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        world_arg,\n        gazebo\n    ])\n"})}),"\n",(0,o.jsx)(e.h3,{id:"running-the-simulation",children:"Running the Simulation"}),"\n",(0,o.jsx)(e.p,{children:"To run a physics simulation:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Source your ROS 2 environment"}),"\n",(0,o.jsxs)(e.li,{children:["Launch the simulation: ",(0,o.jsx)(e.code,{children:"ros2 launch examples_gazebo basic_physics.launch.py"})]}),"\n",(0,o.jsx)(e.li,{children:"Monitor the simulation in Gazebo GUI"}),"\n",(0,o.jsx)(e.li,{children:"Interact with the robot using ROS 2 commands"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"controlling-robot-joints",children:"Controlling Robot Joints"}),"\n",(0,o.jsx)(e.h3,{id:"joint-state-publisher",children:"Joint State Publisher"}),"\n",(0,o.jsx)(e.p,{children:"The joint state publisher broadcasts current joint positions:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport math\n\n\nclass JointController(Node):\n    def __init__(self):\n        super().__init__('joint_controller')\n\n        # Publisher for joint states\n        self.joint_pub = self.create_publisher(JointState, '/joint_states', 10)\n\n        # Timer for publishing\n        self.timer = self.create_timer(0.1, self.publish_joint_states)\n\n        # Initialize joint names and positions\n        self.joint_names = [\n            'left_shoulder', 'left_elbow', 'right_shoulder', 'right_elbow',\n            'left_hip', 'left_knee', 'right_hip', 'right_knee'\n        ]\n        self.joint_positions = [0.0] * len(self.joint_names)\n\n    def publish_joint_states(self):\n        \"\"\"Publish joint state messages.\"\"\"\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n\n        self.joint_pub.publish(msg)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"trajectory-control",children:"Trajectory Control"}),"\n",(0,o.jsx)(e.p,{children:"For more sophisticated control, use trajectory messages:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\n\ndef send_trajectory_command(self, joint_names, positions, duration=1.0):\n    """Send a trajectory command to move joints."""\n    msg = JointTrajectory()\n    msg.joint_names = joint_names\n\n    point = JointTrajectoryPoint()\n    point.positions = positions\n    point.time_from_start.sec = int(duration)\n    point.time_from_start.nanosec = int((duration - int(duration)) * 1e9)\n\n    msg.points.append(point)\n\n    self.trajectory_pub.publish(msg)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"testing-physics-simulation",children:"Testing Physics Simulation"}),"\n",(0,o.jsx)(e.h3,{id:"basic-movement-test",children:"Basic Movement Test"}),"\n",(0,o.jsx)(e.p,{children:"Verify that your physics simulation works by testing basic movements:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Launch the simulation"}),"\n",(0,o.jsx)(e.li,{children:"Send joint commands to move arms/legs"}),"\n",(0,o.jsx)(e.li,{children:"Observe the robot's response in Gazebo"}),"\n",(0,o.jsx)(e.li,{children:"Check for realistic physics behavior (gravity, collisions)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"environmental-interaction-test",children:"Environmental Interaction Test"}),"\n",(0,o.jsx)(e.p,{children:"Test how the robot interacts with the environment:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Position the robot near objects"}),"\n",(0,o.jsx)(e.li,{children:"Move limbs to make contact with objects"}),"\n",(0,o.jsx)(e.li,{children:"Verify that collisions are handled properly"}),"\n",(0,o.jsx)(e.li,{children:"Check that the robot maintains balance appropriately"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"physics-fidelity-vs-performance",children:"Physics Fidelity vs Performance"}),"\n",(0,o.jsx)(e.p,{children:"Balance physics accuracy with simulation speed:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"High fidelity"}),": Small time steps, many solver iterations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Performance"}),": Larger time steps, fewer iterations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Education"}),": Medium settings for balance of accuracy and speed"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"real-time-factor",children:"Real-Time Factor"}),"\n",(0,o.jsx)(e.p,{children:"Monitor the real-time factor to ensure smooth simulation:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RTF = 1.0"}),": Simulation running at real-time speed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RTF < 1.0"}),": Simulation slower than real-time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RTF > 1.0"}),": Simulation faster than real-time (if possible)"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"robot-falling-through-ground",children:"Robot Falling Through Ground"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check collision geometries in URDF"}),"\n",(0,o.jsx)(e.li,{children:"Verify inertial properties are properly defined"}),"\n",(0,o.jsx)(e.li,{children:"Ensure mass values are realistic"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"unstable-joint-movements",children:"Unstable Joint Movements"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjust solver parameters (iterations, SOR value)"}),"\n",(0,o.jsx)(e.li,{children:"Check joint limits and safety controllers"}),"\n",(0,o.jsx)(e.li,{children:"Verify PID controller gains"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"slow-simulation-performance",children:"Slow Simulation Performance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Increase time step size"}),"\n",(0,o.jsx)(e.li,{children:"Reduce solver iterations"}),"\n",(0,o.jsx)(e.li,{children:"Simplify collision geometries"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"model-design",children:"Model Design"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Keep URDF models as simple as possible while maintaining accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Use realistic mass and inertia values"}),"\n",(0,o.jsx)(e.li,{children:"Properly configure joint limits and safety controllers"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"simulation-setup",children:"Simulation Setup"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Start with basic physics parameters and tune as needed"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate world files for different testing scenarios"}),"\n",(0,o.jsx)(e.li,{children:"Monitor simulation performance metrics"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter covered the fundamentals of physics simulation in Gazebo for humanoid robots. You learned how to:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Configure physics engines and parameters for realistic simulation"}),"\n",(0,o.jsx)(e.li,{children:"Create world files that integrate humanoid robot models"}),"\n",(0,o.jsx)(e.li,{children:"Launch and run physics simulations with ROS 2"}),"\n",(0,o.jsx)(e.li,{children:"Control robot joints and observe physics interactions"}),"\n",(0,o.jsx)(e.li,{children:"Optimize simulation performance for different use cases"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"The next chapter will explore how to simulate various sensors in Gazebo and connect them to ROS 2 topics for perception capabilities."}),"\n",(0,o.jsx)(e.h2,{id:"physics-simulation-concepts-and-code-examples",children:"Physics Simulation Concepts and Code Examples"}),"\n",(0,o.jsx)(e.h3,{id:"joint-control-implementation",children:"Joint Control Implementation"}),"\n",(0,o.jsx)(e.p,{children:"The joint control interface allows you to control robot joints programmatically. Here's a complete example:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nJoint Control Interface for Robot in Gazebo Simulation\n\nThis module provides an interface to control robot joints in Gazebo simulation\nusing ROS 2 topics and services.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport time\nimport math\n\n\nclass JointController(Node):\n    """\n    A ROS 2 node for controlling robot joints in Gazebo simulation.\n    """\n\n    def __init__(self):\n        super().__init__(\'joint_controller\')\n\n        # Publisher for joint commands\n        self.joint_cmd_publisher = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_group_position_controller/commands\',\n            10\n        )\n\n        # Publisher for trajectory commands\n        self.trajectory_publisher = self.create_publisher(\n            JointTrajectory,\n            \'/joint_trajectory_controller/joint_trajectory\',\n            10\n        )\n\n        # Subscriber for joint states\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Store current joint states\n        self.current_joint_states = JointState()\n\n        # Timer for periodic updates\n        self.timer = self.create_timer(0.1, self.timer_callback)\n\n        self.get_logger().info(\'Joint Controller node initialized\')\n\n    def joint_state_callback(self, msg):\n        """Callback function to receive joint state updates."""\n        self.current_joint_states = msg\n        self.get_logger().debug(f\'Received joint states: {msg.name}\')\n\n    def timer_callback(self):\n        """Timer callback for periodic operations."""\n        pass\n\n    def move_joints_to_position(self, joint_names, positions, duration=1.0):\n        """\n        Move specified joints to target positions.\n\n        Args:\n            joint_names (list): List of joint names to control\n            positions (list): List of target positions (in radians)\n            duration (float): Time to reach target position (in seconds)\n        """\n        if len(joint_names) != len(positions):\n            self.get_logger().error(\'Joint names and positions must have the same length\')\n            return False\n\n        # Create trajectory message\n        trajectory_msg = JointTrajectory()\n        trajectory_msg.joint_names = joint_names\n\n        point = JointTrajectoryPoint()\n        point.positions = positions\n        point.time_from_start.sec = int(duration)\n        point.time_from_start.nanosec = int((duration - int(duration)) * 1e9)\n\n        trajectory_msg.points.append(point)\n\n        # Publish trajectory\n        self.trajectory_publisher.publish(trajectory_msg)\n        self.get_logger().info(f\'Moving joints {joint_names} to positions {positions}\')\n\n        return True\n\n    def move_arm_to_position(self, left_shoulder_pos=0.0, left_elbow_pos=0.0,\n                            right_shoulder_pos=0.0, right_elbow_pos=0.0):\n        """\n        Move robot arms to specific positions.\n\n        Args:\n            left_shoulder_pos (float): Left shoulder joint position (radians)\n            left_elbow_pos (float): Left elbow joint position (radians)\n            right_shoulder_pos (float): Right shoulder joint position (radians)\n            right_elbow_pos (float): Right elbow joint position (radians)\n        """\n        joint_names = [\'left_shoulder\', \'left_elbow\', \'right_shoulder\', \'right_elbow\']\n        positions = [left_shoulder_pos, left_elbow_pos, right_shoulder_pos, right_elbow_pos]\n\n        return self.move_joints_to_position(joint_names, positions)\n\n    def move_leg_to_position(self, left_hip_pos=0.0, left_knee_pos=0.0,\n                            right_hip_pos=0.0, right_knee_pos=0.0):\n        """\n        Move robot legs to specific positions.\n\n        Args:\n            left_hip_pos (float): Left hip joint position (radians)\n            left_knee_pos (float): Left knee joint position (radians)\n            right_hip_pos (float): Right hip joint position (radians)\n            right_knee_pos (float): Right knee joint position (radians)\n        """\n        joint_names = [\'left_hip\', \'left_knee\', \'right_hip\', \'right_knee\']\n        positions = [left_hip_pos, left_knee_pos, right_hip_pos, right_knee_pos]\n\n        return self.move_joints_to_position(joint_names, positions)\n\n    def wave_arm(self, arm=\'left\', cycles=3):\n        """\n        Make the robot wave its arm.\n\n        Args:\n            arm (str): \'left\' or \'right\' arm to wave\n            cycles (int): Number of waving cycles\n        """\n        if arm == \'left\':\n            joint_names = [\'left_shoulder\', \'left_elbow\']\n        else:\n            joint_names = [\'right_shoulder\', \'right_elbow\']\n\n        self.get_logger().info(f\'Making {arm} arm wave for {cycles} cycles\')\n\n        for i in range(cycles):\n            # Wave up\n            positions_up = [0.5, -0.5] if arm == \'left\' else [-0.5, -0.5]\n            self.move_joints_to_position(joint_names, positions_up, 1.0)\n            time.sleep(1.0)\n\n            # Wave down\n            positions_down = [0.0, 0.0]\n            self.move_joints_to_position(joint_names, positions_down, 1.0)\n            time.sleep(1.0)\n\n    def get_current_joint_positions(self):\n        """Get current joint positions."""\n        return dict(zip(self.current_joint_states.name, self.current_joint_states.position))\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-configuration-best-practices",children:"Physics Configuration Best Practices"}),"\n",(0,o.jsx)(e.p,{children:"When configuring physics for humanoid robots, consider these best practices:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gravity"}),": Use standard Earth gravity (9.81 m/s\xb2) unless simulating other environments"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Time Step"}),": Start with 0.001s for accuracy, increase if performance is critical"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real Time Factor"}),": 1.0 for real-time simulation, higher for faster-than-real-time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solver Iterations"}),": Higher values for stability, lower for performance"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"launch-file-configuration",children:"Launch File Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Example of a comprehensive launch file for physics simulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.actions import ExecuteProcess\nimport os\n\n\ndef generate_launch_description():\n    \"\"\"Launch Gazebo with a basic humanoid robot model.\"\"\"\n\n    # Declare launch arguments\n    world_arg = DeclareLaunchArgument(\n        'world',\n        default_value='basic_humanoid.sdf',\n        description='Choose one of the world files from `/examples/gazebo/worlds`'\n    )\n\n    # Define paths\n    project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))  # Go up to project root\n    world_path = os.path.join(project_root, 'examples', 'gazebo', 'worlds', 'basic_humanoid.sdf')\n    urdf_path = os.path.join(project_root, 'examples', 'gazebo', 'models', 'humanoid', 'basic_humanoid.urdf')\n\n    # Launch Gazebo with the world\n    gazebo = ExecuteProcess(\n        cmd=['gz', 'sim', '-r', world_path],\n        output='screen'\n    )\n\n    # Launch robot state publisher to publish URDF\n    with open(urdf_path, 'r') as infp:\n        robot_desc = infp.read()\n\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[{\n            'robot_description': robot_desc\n        }]\n    )\n\n    # Launch joint state publisher\n    joint_state_publisher = Node(\n        package='joint_state_publisher',\n        executable='joint_state_publisher',\n        name='joint_state_publisher',\n        parameters=[{\n            'use_gui': False,\n            'rate': 50.0\n        }]\n    )\n\n    return LaunchDescription([\n        world_arg,\n        gazebo,\n        robot_state_publisher,\n        joint_state_publisher\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Basic World Creation"}),": Create a simple world file with a humanoid robot and run the simulation."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joint Control"}),": Implement joint controllers to make the robot perform simple movements."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Physics Tuning"}),": Experiment with different physics parameters to observe their effects."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Environmental Interaction"}),": Test how the robot interacts with objects in the environment."]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(h,{...n})}):h(n)}}}]);