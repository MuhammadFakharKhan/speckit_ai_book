"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[559],{3023(e,n,a){a.d(n,{R:()=>r,x:()=>s});var t=a(3696);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},4795(e,n,a){a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>_,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var t=a(2540),o=a(3023);const i={title:"Behavior Tree Configurations for Humanoid Navigation",description:"Behavior tree configurations adapted for humanoid robot navigation using Nav2, including custom nodes for bipedal locomotion",sidebar_position:5,tags:["behavior-tree","navigation","nav2","humanoid","custom-nodes"]},r="Behavior Tree Configurations for Humanoid Navigation",s={id:"nav2-humanoid/behavior-tree-configurations",title:"Behavior Tree Configurations for Humanoid Navigation",description:"Behavior tree configurations adapted for humanoid robot navigation using Nav2, including custom nodes for bipedal locomotion",source:"@site/docs/nav2-humanoid/behavior-tree-configurations.md",sourceDirName:"nav2-humanoid",slug:"/nav2-humanoid/behavior-tree-configurations",permalink:"/docs/nav2-humanoid/behavior-tree-configurations",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nav2-humanoid/behavior-tree-configurations.md",tags:[{label:"behavior-tree",permalink:"/docs/tags/behavior-tree"},{label:"navigation",permalink:"/docs/tags/navigation"},{label:"nav2",permalink:"/docs/tags/nav-2"},{label:"humanoid",permalink:"/docs/tags/humanoid"},{label:"custom-nodes",permalink:"/docs/tags/custom-nodes"}],version:"current",sidebarPosition:5,frontMatter:{title:"Behavior Tree Configurations for Humanoid Navigation",description:"Behavior tree configurations adapted for humanoid robot navigation using Nav2, including custom nodes for bipedal locomotion",sidebar_position:5,tags:["behavior-tree","navigation","nav2","humanoid","custom-nodes"]}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Behavior Tree Fundamentals for Humanoid Robots",id:"behavior-tree-fundamentals-for-humanoid-robots",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Basic Behavior Tree Structure",id:"basic-behavior-tree-structure",level:3},{value:"Custom Behavior Tree Nodes for Humanoid Robots",id:"custom-behavior-tree-nodes-for-humanoid-robots",level:2},{value:"Step Execution Node",id:"step-execution-node",level:3},{value:"Balance Recovery Node",id:"balance-recovery-node",level:3},{value:"Humanoid-Specific Behavior Tree Configurations",id:"humanoid-specific-behavior-tree-configurations",level:2},{value:"Basic Humanoid Navigation Tree",id:"basic-humanoid-navigation-tree",level:3},{value:"Complex Navigation Scenarios",id:"complex-navigation-scenarios",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:2},{value:"Behavior Tree Configuration File",id:"behavior-tree-configuration-file",level:3},{value:"Humanoid-Specific Nodes Implementation",id:"humanoid-specific-nodes-implementation",level:2},{value:"Balance Check Condition Node",id:"balance-check-condition-node",level:3},{value:"Gait Adaptation Node",id:"gait-adaptation-node",level:3},{value:"Integration with Navigation System",id:"integration-with-navigation-system",level:2},{value:"Behavior Tree Integration Example",id:"behavior-tree-integration-example",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Tree Design Best Practices",id:"tree-design-best-practices",level:3},{value:"Configuration Best Practices",id:"configuration-best-practices",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging Strategies",id:"debugging-strategies",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"behavior-tree-configurations-for-humanoid-navigation",children:"Behavior Tree Configurations for Humanoid Navigation"}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Behavior trees in Nav2 provide a flexible framework for controlling robot navigation behavior. For humanoid robots, behavior trees require special configurations to account for bipedal locomotion, balance requirements, and unique navigation challenges. This document covers how to configure behavior trees specifically for humanoid robot navigation."}),"\n",(0,t.jsx)(n.h2,{id:"behavior-tree-fundamentals-for-humanoid-robots",children:"Behavior Tree Fundamentals for Humanoid Robots"}),"\n",(0,t.jsx)(n.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.p,{children:"Behavior trees in Nav2 for humanoid robots must account for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Balance requirements"}),": Navigation decisions must consider robot balance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Step-by-step execution"}),": Movement occurs in discrete steps"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gait patterns"}),": Different walking patterns for different situations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery behaviors"}),": Balance recovery and obstacle avoidance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"3D navigation"}),": Movement in three dimensions including elevation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-behavior-tree-structure",children:"Basic Behavior Tree Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Basic humanoid navigation behavior tree --\x3e\n<root main_tree_to_execute="MainTree">\n    <BehaviorTree ID="MainTree">\n        <Sequence>\n            <GoalUpdated/>\n            <ComputePathToPose goal="{goal}" path="{path}"/>\n            <Fallback name="ExecutePathFallback">\n                <RecoveryNode number_of_retries="2">\n                    <Sequence>\n                        <SmoothPath path="{path}" output="{smoothed_path}"/>\n                        <PlanFootsteps path="{smoothed_path}" footsteps="{footsteps}"/>\n                        <FollowFootsteps footsteps="{footsteps}"/>\n                    </Sequence>\n                    <ClearEntireCostmap name="ClearLocalCostmap" service_name="local_costmap/clear_entirely_local_costmap"/>\n                </RecoveryNode>\n                <ReactiveFallback>\n                    <CheckGoalReaching>\n                        <GoalReached goal="{goal}" tolerance="0.5"/>\n                    </CheckGoalReaching>\n                    <RecoveryNode number_of_retries="2">\n                        <Spin spin_dist="1.57"/>\n                        <Wait wait_duration="5"/>\n                    </RecoveryNode>\n                </ReactiveFallback>\n            </Fallback>\n        </Sequence>\n    </BehaviorTree>\n</root>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"custom-behavior-tree-nodes-for-humanoid-robots",children:"Custom Behavior Tree Nodes for Humanoid Robots"}),"\n",(0,t.jsx)(n.h3,{id:"step-execution-node",children:"Step Execution Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Custom behavior tree node for step execution\n#include "behaviortree_cpp_v3/action_node.h"\n#include "geometry_msgs/msg/pose.hpp"\n#include "std_msgs/msg/bool.hpp"\n#include "rclcpp/rclcpp.hpp"\n\nclass StepExecutionNode : public BT::StatefulActionNode\n{\npublic:\n    StepExecutionNode(const std::string& name, const BT::NodeConfiguration& config)\n        : BT::StatefulActionNode(name, config)\n    {\n        node_ = rclcpp::Node::make_shared("step_execution_node");\n        step_publisher_ = node_->create_publisher<geometry_msgs::msg::Pose>("/step_command", 10);\n        balance_subscriber_ = node_->create_subscription<std_msgs::msg::Bool>(\n            "/balance_status", 10,\n            std::bind(&StepExecutionNode::balanceCallback, this, std::placeholders::_1)\n        );\n    }\n\n    static BT::PortsList providedPorts()\n    {\n        return {\n            BT::InputPort<geometry_msgs::msg::Pose>("step_pose", "The pose for the next step")\n        };\n    }\n\nprivate:\n    // Method invoked at the beginning of the tick\n    BT::NodeStatus onStart() override\n    {\n        if (!getInput<geometry_msgs::msg::Pose>("step_pose", step_pose_)) {\n            throw BT::RuntimeError("Missing required input [step_pose]");\n        }\n\n        // Check if robot is in balance state\n        if (!balance_ok_) {\n            return BT::NodeStatus::FAILURE;\n        }\n\n        // Execute the step\n        step_publisher_->publish(step_pose_);\n        step_execution_start_time_ = node_->get_clock()->now();\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    // Method invoked at every tick during the RUNNING state\n    BT::NodeStatus onRunning() override\n    {\n        // Check if step execution has completed\n        if (step_execution_completed_) {\n            step_execution_completed_ = false;\n            return BT::NodeStatus::SUCCESS;\n        }\n\n        // Check for timeout\n        auto elapsed = node_->get_clock()->now() - step_execution_start_time_;\n        if (elapsed.seconds() > 5.0) { // 5 second timeout\n            return BT::NodeStatus::FAILURE;\n        }\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    // Method invoked upon successful completion or during halt()\n    void onHalted() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Step execution halted");\n    }\n\n    void balanceCallback(const std_msgs::msg::Bool::SharedPtr msg)\n    {\n        balance_ok_ = msg->data;\n    }\n\n    rclcpp::Node::SharedPtr node_;\n    rclcpp::Publisher<geometry_msgs::msg::Pose>::SharedPtr step_publisher_;\n    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr balance_subscriber_;\n\n    geometry_msgs::msg::Pose step_pose_;\n    rclcpp::Time step_execution_start_time_;\n    bool step_execution_completed_ = false;\n    bool balance_ok_ = true;\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"balance-recovery-node",children:"Balance Recovery Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Custom behavior tree node for balance recovery\nclass BalanceRecoveryNode : public BT::StatefulActionNode\n{\npublic:\n    BalanceRecoveryNode(const std::string& name, const BT::NodeConfiguration& config)\n        : BT::StatefulActionNode(name, config)\n    {\n        node_ = rclcpp::Node::make_shared("balance_recovery_node");\n        recovery_publisher_ = node_->create_publisher<std_msgs::msg::Bool>("/balance_recovery_command", 10);\n        balance_subscriber_ = node_->create_subscription<std_msgs::msg::Bool>(\n            "/balance_status", 10,\n            std::bind(&BalanceRecoveryNode::balanceCallback, this, std::placeholders::_1)\n        );\n    }\n\nprivate:\n    BT::NodeStatus onStart() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Initiating balance recovery");\n\n        // Publish recovery command\n        auto recovery_msg = std_msgs::msg::Bool();\n        recovery_msg.data = true;\n        recovery_publisher_->publish(recovery_msg);\n\n        recovery_start_time_ = node_->get_clock()->now();\n        recovery_in_progress_ = true;\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    BT::NodeStatus onRunning() override\n    {\n        // Check if balance has been recovered\n        if (balance_ok_) {\n            recovery_in_progress_ = false;\n            return BT::NodeStatus::SUCCESS;\n        }\n\n        // Check for timeout\n        auto elapsed = node_->get_clock()->now() - recovery_start_time_;\n        if (elapsed.seconds() > 10.0) { // 10 second timeout\n            recovery_in_progress_ = false;\n            return BT::NodeStatus::FAILURE;\n        }\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    void onHalted() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Balance recovery halted");\n        recovery_in_progress_ = false;\n    }\n\n    void balanceCallback(const std_msgs::msg::Bool::SharedPtr msg)\n    {\n        if (recovery_in_progress_) {\n            balance_ok_ = msg->data;\n        }\n    }\n\n    rclcpp::Node::SharedPtr node_;\n    rclcpp::Publisher<std_msgs::msg::Bool>::SharedPtr recovery_publisher_;\n    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr balance_subscriber_;\n\n    rclcpp::Time recovery_start_time_;\n    bool recovery_in_progress_ = false;\n    bool balance_ok_ = true;\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"humanoid-specific-behavior-tree-configurations",children:"Humanoid-Specific Behavior Tree Configurations"}),"\n",(0,t.jsx)(n.h3,{id:"basic-humanoid-navigation-tree",children:"Basic Humanoid Navigation Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Complete humanoid navigation behavior tree --\x3e\n<root main_tree_to_execute="MainTree">\n    <BehaviorTree ID="MainTree">\n        <ReactiveSequence name="MainSequence">\n            <GoalUpdated/>\n            <Fallback name="GlobalPlannerFallback">\n                <Sequence name="GlobalPlanAndNavigate">\n                    <ComputePathToPose goal="{goal}" path="{path}"/>\n                    <Fallback name="LocalPlannerFallback">\n                        <RecoveryNode number_of_retries="3" name="NavigateWithRecovery">\n                            <Sequence name="NavigateSequence">\n                                <SmoothPath path="{path}" output="{smoothed_path}"/>\n                                <PlanFootsteps path="{smoothed_path}" footsteps="{footsteps}"/>\n                                <Fallback name="StepExecutionFallback">\n                                    <FollowFootsteps footsteps="{footsteps}"/>\n                                    <ReactiveSequence name="BalanceRecoverySequence">\n                                        <CheckBalance status="{balance_status}"/>\n                                        <BalanceRecoveryNode/>\n                                        <Wait wait_duration="2.0"/>\n                                    </ReactiveSequence>\n                                </Fallback>\n                            </Sequence>\n                            <ClearEntireCostmap name="ClearLocalCostmap" service_name="local_costmap/clear_entirely_local_costmap"/>\n                        </RecoveryNode>\n                        <ReactiveSequence name="GoalReachingFallback">\n                            <CheckGoalReaching goal="{goal}" tolerance="0.5">\n                                <GoalReached goal="{goal}" tolerance="0.5"/>\n                            </CheckGoalReaching>\n                            <RecoveryNode number_of_retries="2" name="GoalRecovery">\n                                <Spin spin_dist="1.57"/>\n                                <Wait wait_duration="3.0"/>\n                            </RecoveryNode>\n                        </ReactiveSequence>\n                    </Fallback>\n                </Sequence>\n                <ReactiveSequence name="GlobalPlanFailure">\n                    <GoalReached goal="{goal}" tolerance="1.0"/>\n                    <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>\n                </ReactiveSequence>\n            </Fallback>\n        </ReactiveSequence>\n    </BehaviorTree>\n\n    \x3c!-- Custom nodes definition --\x3e\n    <TreeNodeModel>\n        <Action ID="BalanceRecoveryNode">\n            <input_port name="recovery_type" type="std::string" default="step_in_place"/>\n        </Action>\n        <Condition ID="CheckBalance">\n            <output_port name="status" type="bool"/>\n        </Condition>\n        <Action ID="FollowFootsteps">\n            <input_port name="footsteps" type="nav2_msgs::msg::Path"/>\n        </Action>\n        <Action ID="PlanFootsteps">\n            <input_port name="path" type="nav2_msgs::msg::Path"/>\n            <output_port name="footsteps" type="nav2_msgs::msg::Path"/>\n        </Action>\n    </TreeNodeModel>\n</root>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"complex-navigation-scenarios",children:"Complex Navigation Scenarios"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Advanced humanoid navigation tree for complex scenarios --\x3e\n<root main_tree_to_execute="AdvancedMainTree">\n    <BehaviorTree ID="AdvancedMainTree">\n        <ReactiveSequence name="AdvancedNavigation">\n            <GoalUpdated/>\n            <Fallback name="PlanningFallback">\n                \x3c!-- Primary navigation approach --\x3e\n                <Sequence name="PrimaryNavigation">\n                    <ComputePathToPose goal="{goal}" path="{path}"/>\n                    <Fallback name="ExecutionFallback">\n                        <RecoveryNode number_of_retries="5" name="PrimaryExecution">\n                            <Sequence name="PrimaryExecutionSequence">\n                                <SmoothPath path="{path}" output="{smoothed_path}"/>\n                                <PlanFootsteps path="{smoothed_path}" footsteps="{footsteps}"/>\n                                <NavigateWithSteps footsteps="{footsteps}"/>\n                            </Sequence>\n                            <ClearEntireCostmap name="ClearLocalCostmap"/>\n                        </RecoveryNode>\n                        \x3c!-- Alternative navigation if primary fails --\x3e\n                        <Sequence name="AlternativeNavigation">\n                            <ComputePathToPose goal="{goal}" path="{alt_path}" planner_id="dwb_core"/>\n                            <RecoveryNode number_of_retries="3" name="AltExecution">\n                                <NavigateWithSteps path="{alt_path}"/>\n                                <ClearEntireCostmap name="ClearAltCostmap"/>\n                            </RecoveryNode>\n                        </Sequence>\n                    </Fallback>\n                </Sequence>\n                \x3c!-- Emergency navigation if planning fails --\x3e\n                <Sequence name="EmergencyNavigation">\n                    <Fallback name="EmergencyFallback">\n                        <NavigateToPose goal="{goal}" controller_server="emergency_controller"/>\n                        <ReactiveSequence name="EmergencyRecovery">\n                            <GoalReached goal="{goal}" tolerance="2.0"/>\n                            <Wait wait_duration="5.0"/>\n                        </ReactiveSequence>\n                    </Fallback>\n                </Sequence>\n            </Fallback>\n        </ReactiveSequence>\n    </BehaviorTree>\n\n    \x3c!-- Emergency and safety behaviors --\x3e\n    <BehaviorTree ID="EmergencyTree">\n        <ReactiveSequence name="EmergencySequence">\n            <CheckEmergencyStop condition="{emergency_stop}"/>\n            <EmergencyStopBehavior/>\n            <Fallback name="RecoveryFallback">\n                <BalanceRecoveryNode recovery_type="emergency"/>\n                <Wait wait_duration="1.0"/>\n            </Fallback>\n        </ReactiveSequence>\n    </BehaviorTree>\n</root>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,t.jsx)(n.h3,{id:"behavior-tree-configuration-file",children:"Behavior Tree Configuration File"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# Behavior tree configuration for humanoid navigation\nbehavior_tree:\n  ros__parameters:\n    # Default behavior tree XML file\n    default_bt_xml_filename: "humanoid_navigation_tree.xml"\n\n    # Enable behavior tree logging\n    enable_bt_tree_logging: true\n    enable_bt_node_logging: true\n\n    # Blackboard cleanup parameters\n    blackboard_cleanup_service: "cleanup_blackboard"\n\n    # Server parameters\n    enable_groot_monitoring: true\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n\n    # Recovery parameters\n    number_of_recoveries: 5\n    enable_recovery: true\n\n    # Humanoid-specific parameters\n    step_execution_timeout: 5.0\n    balance_check_frequency: 10.0\n    gait_adaptation_enabled: true\n    recovery_step_size: 0.3\n    max_recovery_attempts: 3\n\n# Server configuration for behavior tree nodes\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    default_bt_xml_filename: "humanoid_navigation_tree.xml"\n    plugin_lib_names: [\n      "bt_navigator/wait",\n      "bt_navigator/spin",\n      "bt_navigator/back_up",\n      "bt_navigator/unicycle_controller",\n      "nav2_compute_path_to_pose_action_bt_node",\n      "nav2_follow_path_action_bt_node",\n      "nav2_back_up_action_bt_node",\n      "nav2_spin_action_bt_node",\n      "nav2_wait_action_bt_node",\n      "nav2_clear_costmap_service_bt_node",\n      "nav2_is_path_valid_condition_bt_node",\n      "nav2_is_stuck_condition_bt_node",\n      "nav2_is_goal_reached_condition_bt_node",\n      "nav2_is_path_blocked_condition_bt_node",\n      "nav2_reinitialize_global_localization_service_bt_node",\n      "nav2_rate_controller_bt_node",\n      "nav2_distance_controller_bt_node",\n      "nav2_speed_controller_bt_node",\n      "nav2_truncate_path_action_bt_node",\n      "nav2_goal_updater_node_bt_node",\n      "nav2_recovery_node_bt_node",\n      "nav2_pipeline_sequence_bt_node",\n      "nav2_round_robin_node_bt_node",\n      "nav2_transform_available_condition_bt_node",\n      "nav2_time_expired_condition_bt_node",\n      "nav2_distance_traveled_condition_bt_node",\n      "humanoid_balance_check_condition",\n      "humanoid_step_execution_action",\n      "humanoid_balance_recovery_action"\n    ]\n'})}),"\n",(0,t.jsx)(n.h2,{id:"humanoid-specific-nodes-implementation",children:"Humanoid-Specific Nodes Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"balance-check-condition-node",children:"Balance Check Condition Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Condition node to check robot balance status\nclass BalanceCheckCondition : public BT::ConditionNode\n{\npublic:\n    BalanceCheckCondition(const std::string& name, const BT::NodeConfiguration& config)\n        : BT::ConditionNode(name, config)\n    {\n        node_ = rclcpp::Node::make_shared("balance_check_condition");\n        balance_subscriber_ = node_->create_subscription<std_msgs::msg::Bool>(\n            "/balance_status", 10,\n            std::bind(&BalanceCheckCondition::balanceCallback, this, std::placeholders::_1)\n        );\n    }\n\n    static BT::PortsList providedPorts()\n    {\n        return {\n            BT::OutputPort<bool>("balance_status", "Current balance status")\n        };\n    }\n\nprivate:\n    BT::NodeStatus tick() override\n    {\n        // Update balance status in blackboard if port is provided\n        if (getOutput<bool>("balance_status", balance_status_)) {\n            setOutput("balance_status", balance_status_);\n        }\n\n        // Return status based on balance\n        return balance_status_ ? BT::NodeStatus::SUCCESS : BT::NodeStatus::FAILURE;\n    }\n\n    void balanceCallback(const std_msgs::msg::Bool::SharedPtr msg)\n    {\n        balance_status_ = msg->data;\n    }\n\n    rclcpp::Node::SharedPtr node_;\n    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr balance_subscriber_;\n    bool balance_status_ = true;\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"gait-adaptation-node",children:"Gait Adaptation Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Action node for gait adaptation based on terrain\nclass GaitAdaptationNode : public BT::StatefulActionNode\n{\npublic:\n    GaitAdaptationNode(const std::string& name, const BT::NodeConfiguration& config)\n        : BT::StatefulActionNode(name, config)\n    {\n        node_ = rclcpp::Node::make_shared("gait_adaptation_node");\n        gait_publisher_ = node_->create_publisher<std_msgs::msg::String>("/gait_command", 10);\n        terrain_subscriber_ = node_->create_subscription<std_msgs::msg::String>(\n            "/terrain_classification", 10,\n            std::bind(&GaitAdaptationNode::terrainCallback, this, std::placeholders::_1)\n        );\n    }\n\n    static BT::PortsList providedPorts()\n    {\n        return {\n            BT::InputPort<std::string>("preferred_gait", "Preferred gait type")\n        };\n    }\n\nprivate:\n    BT::NodeStatus onStart() override\n    {\n        std::string preferred_gait = "walking";\n        if (getInput<std::string>("preferred_gait", preferred_gait)) {\n            RCLCPP_INFO(node_->get_logger(), "Adapting to preferred gait: %s", preferred_gait.c_str());\n        }\n\n        // Determine appropriate gait based on terrain and preferences\n        std::string selected_gait = determineGait(preferred_gait, current_terrain_);\n\n        // Publish gait command\n        auto gait_msg = std_msgs::msg::String();\n        gait_msg.data = selected_gait;\n        gait_publisher_->publish(gait_msg);\n\n        gait_adaptation_start_time_ = node_->get_clock()->now();\n        gait_adapted_ = false;\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    BT::NodeStatus onRunning() override\n    {\n        // Check if gait adaptation has been confirmed\n        if (gait_adapted_) {\n            return BT::NodeStatus::SUCCESS;\n        }\n\n        // Check for timeout\n        auto elapsed = node_->get_clock()->now() - gait_adaptation_start_time_;\n        if (elapsed.seconds() > 3.0) { // 3 second timeout\n            return BT::NodeStatus::FAILURE;\n        }\n\n        return BT::NodeStatus::RUNNING;\n    }\n\n    void onHalted() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Gait adaptation halted");\n    }\n\n    std::string determineGait(const std::string& preferred_gait, const std::string& terrain)\n    {\n        if (terrain == "rough" || terrain == "uneven") {\n            return "careful";\n        } else if (terrain == "smooth" && preferred_gait == "fast") {\n            return "fast";\n        } else {\n            return "walking";\n        }\n    }\n\n    void terrainCallback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        current_terrain_ = msg->data;\n    }\n\n    rclcpp::Node::SharedPtr node_;\n    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr gait_publisher_;\n    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr terrain_subscriber_;\n\n    std::string current_terrain_ = "unknown";\n    rclcpp::Time gait_adaptation_start_time_;\n    bool gait_adapted_ = false;\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-navigation-system",children:"Integration with Navigation System"}),"\n",(0,t.jsx)(n.h3,{id:"behavior-tree-integration-example",children:"Behavior Tree Integration Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example Python node integrating behavior tree with navigation\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom nav2_msgs.action import NavigateWithRecovery\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import Bool\nimport time\n\nclass HumanoidBTNavigator(Node):\n    def __init__(self):\n        super().__init__('humanoid_bt_navigator')\n\n        # Action client for navigation\n        self.nav_client = ActionClient(self, NavigateWithRecovery, 'navigate_with_recovery')\n\n        # Publishers and subscribers\n        self.balance_sub = self.create_subscription(\n            Bool, '/balance_status', self.balance_callback, 10\n        )\n        self.gait_pub = self.create_publisher(\n            String, '/gait_command', 10\n        )\n\n        # Navigation parameters\n        self.declare_parameter('max_navigation_time', 300.0)  # 5 minutes\n        self.declare_parameter('balance_threshold', 0.8)\n        self.declare_parameter('recovery_enabled', True)\n\n        self.current_balance = 1.0\n        self.navigation_in_progress = False\n\n    def balance_callback(self, msg):\n        \"\"\"\n        Update current balance status\n        \"\"\"\n        self.current_balance = msg.data\n\n    def navigate_to_pose(self, pose):\n        \"\"\"\n        Navigate to specified pose using behavior tree\n        \"\"\"\n        # Wait for action server\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error('Navigation action server not available')\n            return False\n\n        # Create goal\n        goal_msg = NavigateWithRecovery.Goal()\n        goal_msg.pose = pose\n        goal_msg.behavior_tree = self.get_parameter('default_bt_xml_filename').value\n\n        # Send goal\n        self.navigation_in_progress = True\n        future = self.nav_client.send_goal_async(goal_msg)\n        future.add_done_callback(self.navigation_result_callback)\n\n        return True\n\n    def navigation_result_callback(self, future):\n        \"\"\"\n        Handle navigation result\n        \"\"\"\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Navigation goal rejected')\n            self.navigation_in_progress = False\n            return\n\n        self.get_logger().info('Navigation goal accepted')\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.navigation_complete_callback)\n\n    def navigation_complete_callback(self, future):\n        \"\"\"\n        Handle navigation completion\n        \"\"\"\n        result = future.result().result\n        self.get_logger().info(f'Navigation completed with result: {result}')\n        self.navigation_in_progress = False\n\n    def adapt_gait_for_terrain(self, terrain_type):\n        \"\"\"\n        Adapt gait based on terrain type\n        \"\"\"\n        gait_map = {\n            'rough': 'careful',\n            'smooth': 'walking',\n            'stairs': 'cautious',\n            'ramp': 'controlled'\n        }\n\n        selected_gait = gait_map.get(terrain_type, 'walking')\n\n        gait_msg = String()\n        gait_msg.data = selected_gait\n        self.gait_pub.publish(gait_msg)\n\n        self.get_logger().info(f'Adapted gait to: {selected_gait} for terrain: {terrain_type}')\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"tree-design-best-practices",children:"Tree Design Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modularity"}),": Design behavior trees with modular components that can be reused"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Include proper error handling and recovery mechanisms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Balance Safety"}),": Always prioritize balance and safety in navigation decisions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Optimize tree structure to minimize computational overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debugging"}),": Enable logging and monitoring for easier debugging"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-best-practices",children:"Configuration Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Tuning"}),": Carefully tune parameters for your specific humanoid robot"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),": Test behavior trees in simulation before real robot deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring"}),": Implement monitoring to track tree execution and performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fallbacks"}),": Always include fallback behaviors for safety-critical operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tree loops"}),": Ensure proper termination conditions to prevent infinite loops"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Balance failures"}),": Implement proper balance checking and recovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Step execution timeouts"}),": Adjust timeout parameters based on robot capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory issues"}),": Monitor memory usage with complex behavior trees"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"debugging-strategies",children:"Debugging Strategies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Monitor behavior tree execution\nros2 run nav2_msgs bt_tree_logger\n\n# Visualize tree with Groot\nros2 run groot_bt groot_monitor\n\n# Check navigation logs\nros2 param set bt_navigator enable_bt_tree_logging true\n"})}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive guide provides the configuration and implementation details needed for creating behavior trees specifically adapted for humanoid robot navigation using Nav2."})]})}function _(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);