"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[7349],{3023(e,n,t){t.d(n,{R:()=>o,x:()=>r});var a=t(3696);const s={},i=a.createContext(s);function o(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}},8368(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=t(2540),s=t(3023);const i={title:"Balance and Step Dynamics for Navigation",description:"Balance and step dynamics considerations for humanoid robot navigation using Nav2, addressing unique challenges of bipedal locomotion",sidebar_position:6,tags:["balance","dynamics","locomotion","navigation","humanoid","nav2"]},o="Balance and Step Dynamics for Navigation",r={id:"nav2-humanoid/balance-step-dynamics",title:"Balance and Step Dynamics for Navigation",description:"Balance and step dynamics considerations for humanoid robot navigation using Nav2, addressing unique challenges of bipedal locomotion",source:"@site/docs/nav2-humanoid/balance-step-dynamics.md",sourceDirName:"nav2-humanoid",slug:"/nav2-humanoid/balance-step-dynamics",permalink:"/docs/nav2-humanoid/balance-step-dynamics",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nav2-humanoid/balance-step-dynamics.md",tags:[{label:"balance",permalink:"/docs/tags/balance"},{label:"dynamics",permalink:"/docs/tags/dynamics"},{label:"locomotion",permalink:"/docs/tags/locomotion"},{label:"navigation",permalink:"/docs/tags/navigation"},{label:"humanoid",permalink:"/docs/tags/humanoid"},{label:"nav2",permalink:"/docs/tags/nav-2"}],version:"current",sidebarPosition:6,frontMatter:{title:"Balance and Step Dynamics for Navigation",description:"Balance and step dynamics considerations for humanoid robot navigation using Nav2, addressing unique challenges of bipedal locomotion",sidebar_position:6,tags:["balance","dynamics","locomotion","navigation","humanoid","nav2"]}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Fundamentals of Humanoid Balance",id:"fundamentals-of-humanoid-balance",level:2},{value:"Center of Mass and Support Polygon",id:"center-of-mass-and-support-polygon",level:3},{value:"Balance Stability Metrics",id:"balance-stability-metrics",level:3},{value:"Step Dynamics and Planning",id:"step-dynamics-and-planning",level:2},{value:"Step Planning Algorithm",id:"step-planning-algorithm",level:3},{value:"Dynamic Step Adjustment",id:"dynamic-step-adjustment",level:3},{value:"Integration with Nav2 Navigation",id:"integration-with-nav2-navigation",level:2},{value:"Balance-Aware Path Planner",id:"balance-aware-path-planner",level:3},{value:"Balance Monitoring During Navigation",id:"balance-monitoring-during-navigation",level:3},{value:"Step Execution and Timing",id:"step-execution-and-timing",level:2},{value:"Step Execution Controller",id:"step-execution-controller",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Balance and Performance Metrics",id:"balance-and-performance-metrics",level:3},{value:"Troubleshooting and Safety",id:"troubleshooting-and-safety",level:2},{value:"Common Balance Issues and Solutions",id:"common-balance-issues-and-solutions",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Design Guidelines",id:"design-guidelines",level:3},{value:"Implementation Tips",id:"implementation-tips",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"balance-and-step-dynamics-for-navigation",children:"Balance and Step Dynamics for Navigation"}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Humanoid robot navigation requires special consideration of balance and step dynamics that are fundamentally different from wheeled robot navigation. This document covers the key concepts, algorithms, and implementations for managing balance and step dynamics during navigation for bipedal robots using Nav2."}),"\n",(0,a.jsx)(n.h2,{id:"fundamentals-of-humanoid-balance",children:"Fundamentals of Humanoid Balance"}),"\n",(0,a.jsx)(n.h3,{id:"center-of-mass-and-support-polygon",children:"Center of Mass and Support Polygon"}),"\n",(0,a.jsx)(n.p,{children:"The center of mass (CoM) and support polygon are fundamental to humanoid balance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Balance calculation for humanoid robot\nimport numpy as np\n\nclass HumanoidBalanceCalculator:\n    def __init__(self):\n        self.robot_height = 1.0  # meters\n        self.foot_separation = 0.3  # meters\n        self.balance_margin = 0.05  # meters\n\n    def calculate_support_polygon(self, left_foot_pose, right_foot_pose):\n        """\n        Calculate support polygon based on foot positions\n        """\n        # Calculate support polygon vertices\n        # For simplicity, assuming feet form rectangular support area\n        center_x = (left_foot_pose.position.x + right_foot_pose.position.x) / 2\n        center_y = (left_foot_pose.position.y + right_foot_pose.position.y) / 2\n\n        # Calculate width and length of support polygon\n        foot_distance = np.sqrt(\n            (left_foot_pose.position.x - right_foot_pose.position.x)**2 +\n            (left_foot_pose.position.y - right_foot_pose.position.y)**2\n        )\n\n        # Support polygon vertices (simplified as rectangle)\n        vertices = [\n            (center_x - foot_distance/2, center_y - self.foot_separation/2),\n            (center_x + foot_distance/2, center_y - self.foot_separation/2),\n            (center_x + foot_distance/2, center_y + self.foot_separation/2),\n            (center_x - foot_distance/2, center_y + self.foot_separation/2)\n        ]\n\n        return vertices\n\n    def is_balance_stable(self, com_position, support_polygon):\n        """\n        Check if center of mass is within support polygon\n        """\n        # Point-in-polygon test for CoM position\n        x, y = com_position[0], com_position[1]\n\n        # Simplified point-in-rectangle test\n        min_x = min([v[0] for v in support_polygon])\n        max_x = max([v[0] for v in support_polygon])\n        min_y = min([v[1] for v in support_polygon])\n        max_y = max([v[1] for v in support_polygon])\n\n        # Add safety margin\n        min_x += self.balance_margin\n        max_x -= self.balance_margin\n        min_y += self.balance_margin\n        max_y -= self.balance_margin\n\n        return min_x <= x <= max_x and min_y <= y <= max_y\n\n    def calculate_zero_moment_point(self, forces, moments):\n        """\n        Calculate Zero Moment Point (ZMP) for balance analysis\n        """\n        # ZMP = (sum(xi * Fi), sum(yi * Fi)) / sum(Fi)\n        # where xi, yi are positions and Fi are forces\n        total_force = sum([f[2] for f in forces])  # Z component\n        if total_force == 0:\n            return (0, 0)\n\n        zmp_x = sum([pos[0] * force[2] for pos, force in zip(forces, forces)]) / total_force\n        zmp_y = sum([pos[1] * force[2] for pos, force in zip(forces, forces)]) / total_force\n\n        return (zmp_x, zmp_y)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"balance-stability-metrics",children:"Balance Stability Metrics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Balance stability assessment\nclass BalanceStabilityAssessment:\n    def __init__(self):\n        self.stability_threshold = 0.1  # meters from support polygon edge\n        self.com_height_threshold = 0.8  # meters above ground\n        self.max_lean_angle = 15.0  # degrees\n\n    def assess_balance_stability(self, robot_state):\n        \"\"\"\n        Assess overall balance stability\n        \"\"\"\n        stability_metrics = {}\n\n        # 1. Support polygon stability\n        stability_metrics['support_polygon_stable'] = self.check_support_polygon(robot_state)\n\n        # 2. CoM position relative to support polygon\n        stability_metrics['com_margin'] = self.calculate_com_margin(robot_state)\n\n        # 3. ZMP position (should be within support polygon)\n        stability_metrics['zmp_stable'] = self.check_zmp(robot_state)\n\n        # 4. Lean angle\n        stability_metrics['lean_angle'] = self.calculate_lean_angle(robot_state)\n        stability_metrics['lean_angle_acceptable'] = stability_metrics['lean_angle'] < self.max_lean_angle\n\n        # Overall stability score\n        stability_metrics['overall_stability'] = self.calculate_overall_stability(stability_metrics)\n\n        return stability_metrics\n\n    def check_support_polygon(self, robot_state):\n        \"\"\"\n        Check if CoM is within support polygon\n        \"\"\"\n        # Implementation depends on robot state structure\n        return True  # Simplified\n\n    def calculate_com_margin(self, robot_state):\n        \"\"\"\n        Calculate distance from CoM to nearest support polygon edge\n        \"\"\"\n        # Implementation depends on robot state structure\n        return 0.1  # meters\n\n    def check_zmp(self, robot_state):\n        \"\"\"\n        Check if ZMP is within support polygon\n        \"\"\"\n        # Implementation depends on robot state structure\n        return True  # Simplified\n\n    def calculate_lean_angle(self, robot_state):\n        \"\"\"\n        Calculate robot lean angle from upright position\n        \"\"\"\n        # Calculate lean angle from orientation\n        orientation = robot_state.pose.orientation\n        # Convert quaternion to Euler angles and calculate lean\n        # Simplified calculation\n        return 5.0  # degrees\n\n    def calculate_overall_stability(self, metrics):\n        \"\"\"\n        Calculate overall stability score (0-1)\n        \"\"\"\n        weights = {\n            'support_polygon_stable': 0.3,\n            'com_margin': 0.2,\n            'zmp_stable': 0.3,\n            'lean_angle_acceptable': 0.2\n        }\n\n        score = 0.0\n        if metrics['support_polygon_stable']:\n            score += weights['support_polygon_stable']\n\n        if metrics['com_margin'] > 0.05:  # 5cm margin\n            score += weights['com_margin']\n\n        if metrics['zmp_stable']:\n            score += weights['zmp_stable']\n\n        if metrics['lean_angle_acceptable']:\n            score += weights['lean_angle_acceptable']\n\n        return score\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-dynamics-and-planning",children:"Step Dynamics and Planning"}),"\n",(0,a.jsx)(n.h3,{id:"step-planning-algorithm",children:"Step Planning Algorithm"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Step planning for humanoid navigation\nimport math\n\nclass StepPlanner:\n    def __init__(self):\n        self.max_step_length = 0.4  # meters\n        self.max_step_width = 0.3   # meters\n        self.step_height = 0.05     # meters (clearance)\n        self.step_timing = 0.8      # seconds per step\n\n    def plan_next_step(self, current_pose, target_pose, support_foot):\n        """\n        Plan next step based on current pose and target\n        """\n        # Calculate desired step direction and distance\n        dx = target_pose.position.x - current_pose.position.x\n        dy = target_pose.position.y - current_pose.position.y\n        distance = math.sqrt(dx**2 + dy**2)\n\n        # Normalize direction\n        if distance > 0:\n            direction_x = dx / distance\n            direction_y = dy / distance\n        else:\n            direction_x, direction_y = 0, 0\n\n        # Limit step size to maximum capability\n        step_distance = min(distance, self.max_step_length)\n        step_x = current_pose.position.x + direction_x * step_distance\n        step_y = current_pose.position.y + direction_y * step_distance\n\n        # Determine step location based on support foot\n        if support_foot == "left":\n            # Step with right foot\n            step_pose = self.calculate_right_foot_pose(step_x, step_y, current_pose)\n        else:\n            # Step with left foot\n            step_pose = self.calculate_left_foot_pose(step_x, step_y, current_pose)\n\n        # Validate step for balance\n        if self.is_step_balanced(current_pose, step_pose, support_foot):\n            return step_pose\n        else:\n            # Adjust step for better balance\n            return self.adjust_step_for_balance(current_pose, step_pose, support_foot)\n\n    def calculate_left_foot_pose(self, target_x, target_y, current_pose):\n        """\n        Calculate pose for left foot step\n        """\n        # Simplified: place left foot at target position\n        from geometry_msgs.msg import Pose\n        pose = Pose()\n        pose.position.x = target_x\n        pose.position.y = target_y\n        pose.position.z = 0.0  # Ground level\n        pose.orientation = current_pose.orientation  # Maintain orientation\n        return pose\n\n    def calculate_right_foot_pose(self, target_x, target_y, current_pose):\n        """\n        Calculate pose for right foot step\n        """\n        # Simplified: place right foot at target position\n        from geometry_msgs.msg import Pose\n        pose = Pose()\n        pose.position.x = target_x\n        pose.position.y = target_y\n        pose.position.z = 0.0  # Ground level\n        pose.orientation = current_pose.orientation  # Maintain orientation\n        return pose\n\n    def is_step_balanced(self, current_pose, step_pose, support_foot):\n        """\n        Check if proposed step maintains balance\n        """\n        # Calculate new support polygon with proposed step\n        # This is a simplified check\n        return True  # Simplified for example\n\n    def adjust_step_for_balance(self, current_pose, step_pose, support_foot):\n        """\n        Adjust step to maintain better balance\n        """\n        # Adjust step position to maintain balance\n        # Implementation would involve more complex balance calculations\n        return step_pose\n'})}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-step-adjustment",children:"Dynamic Step Adjustment"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Dynamic step adjustment based on environment\nclass DynamicStepAdjuster:\n    def __init__(self):\n        self.step_adjustment_factor = 0.8\n        self.min_step_size = 0.1  # meters\n        self.max_step_size = 0.4  # meters\n\n    def adjust_step_for_environment(self, planned_step, environment_data):\n        """\n        Adjust step based on environmental factors\n        """\n        adjusted_step = planned_step\n\n        # Adjust for terrain type\n        terrain_factor = self.get_terrain_factor(environment_data.terrain_type)\n        adjusted_step = self.scale_step_by_factor(adjusted_step, terrain_factor)\n\n        # Adjust for obstacle proximity\n        if environment_data.obstacles:\n            adjusted_step = self.avoid_obstacles(adjusted_step, environment_data.obstacles)\n\n        # Adjust for surface stability\n        stability_factor = self.get_stability_factor(environment_data.surface_type)\n        adjusted_step = self.scale_step_by_factor(adjusted_step, stability_factor)\n\n        return adjusted_step\n\n    def get_terrain_factor(self, terrain_type):\n        """\n        Get factor based on terrain type\n        """\n        terrain_factors = {\n            \'smooth\': 1.0,\n            \'rough\': 0.7,\n            \'uneven\': 0.6,\n            \'stairs\': 0.5,\n            \'ramp\': 0.8\n        }\n        return terrain_factors.get(terrain_type, 1.0)\n\n    def avoid_obstacles(self, step_pose, obstacles):\n        """\n        Adjust step to avoid obstacles\n        """\n        # Check if step collides with obstacles\n        for obstacle in obstacles:\n            distance_to_obstacle = self.calculate_distance(step_pose, obstacle)\n            if distance_to_obstacle < obstacle.radius + 0.1:  # 10cm safety margin\n                # Adjust step to avoid obstacle\n                step_pose = self.adjust_for_obstacle_avoidance(step_pose, obstacle)\n\n        return step_pose\n\n    def get_stability_factor(self, surface_type):\n        """\n        Get stability factor based on surface type\n        """\n        stability_factors = {\n            \'solid\': 1.0,\n            \'slippery\': 0.6,\n            \'soft\': 0.8,\n            \'uneven\': 0.7\n        }\n        return stability_factors.get(surface_type, 1.0)\n\n    def scale_step_by_factor(self, step_pose, factor):\n        """\n        Scale step size by factor while maintaining direction\n        """\n        # Implementation depends on step representation\n        return step_pose\n\n    def adjust_for_obstacle_avoidance(self, step_pose, obstacle):\n        """\n        Adjust step to avoid specific obstacle\n        """\n        # Calculate avoidance direction\n        # Move step laterally to avoid obstacle\n        return step_pose\n\n    def calculate_distance(self, pose1, pose2):\n        """\n        Calculate distance between two poses\n        """\n        dx = pose1.position.x - pose2.position.x\n        dy = pose1.position.y - pose2.position.y\n        return math.sqrt(dx**2 + dy**2)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-nav2-navigation",children:"Integration with Nav2 Navigation"}),"\n",(0,a.jsx)(n.h3,{id:"balance-aware-path-planner",children:"Balance-Aware Path Planner"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Balance-aware path planning for Nav2\nfrom nav2_core.global_planner import GlobalPlanner\nfrom nav2_core.types import PoseWithUUID, Path\nfrom geometry_msgs.msg import Pose, PoseStamped\nimport numpy as np\n\nclass BalanceAwarePlanner(GlobalPlanner):\n    def __init__(self):\n        super().__init__()\n        self.balance_calculator = HumanoidBalanceCalculator()\n        self.step_planner = StepPlanner()\n        self.max_lean_angle = 15.0  # degrees\n        self.balance_margin = 0.1   # meters\n\n    def create_plan(self, start, goal, map_info):\n        """\n        Create balance-aware path plan\n        """\n        # Use standard path planning first\n        raw_path = self.plan_standard_path(start, goal, map_info)\n\n        if not raw_path:\n            return []\n\n        # Adapt path for balance requirements\n        balance_safe_path = self.adapt_path_for_balance(raw_path)\n\n        # Generate step sequence for humanoid execution\n        humanoid_path = self.generate_step_sequence(balance_safe_path)\n\n        return humanoid_path\n\n    def plan_standard_path(self, start, goal, map_info):\n        """\n        Plan standard path using A* or similar algorithm\n        """\n        # Implementation of standard path planning\n        # This would use Nav2\'s standard planning algorithms\n        return [start, goal]  # Simplified for example\n\n    def adapt_path_for_balance(self, raw_path):\n        """\n        Adapt path to maintain balance throughout navigation\n        """\n        adapted_path = []\n        for i in range(len(raw_path) - 1):\n            current_pose = raw_path[i]\n            next_pose = raw_path[i + 1]\n\n            # Check if direct transition maintains balance\n            if self.is_transition_balanced(current_pose, next_pose):\n                adapted_path.append(next_pose)\n            else:\n                # Insert intermediate poses to maintain balance\n                intermediate_poses = self.generate_balance_preserving_path(current_pose, next_pose)\n                adapted_path.extend(intermediate_poses)\n\n        return adapted_path\n\n    def is_transition_balanced(self, pose1, pose2):\n        """\n        Check if transition between poses maintains balance\n        """\n        # Calculate step size and direction\n        dx = pose2.position.x - pose1.position.x\n        dy = pose2.position.y - pose1.position.y\n        step_distance = math.sqrt(dx**2 + dy**2)\n\n        # Check if step size is within balance limits\n        if step_distance > self.step_planner.max_step_length * 0.8:  # 80% of max for safety\n            return False\n\n        # Additional balance checks could go here\n        return True\n\n    def generate_balance_preserving_path(self, start_pose, end_pose):\n        """\n        Generate intermediate poses to maintain balance\n        """\n        intermediate_poses = []\n\n        # Calculate intermediate steps\n        dx = end_pose.position.x - start_pose.position.x\n        dy = end_pose.position.y - start_pose.position.y\n        distance = math.sqrt(dx**2 + dy**2)\n\n        # Calculate number of intermediate steps needed\n        num_steps = int(distance / (self.step_planner.max_step_length * 0.5)) + 1\n\n        for i in range(1, num_steps):\n            ratio = i / num_steps\n            intermediate_pose = Pose()\n            intermediate_pose.position.x = start_pose.position.x + dx * ratio\n            intermediate_pose.position.y = start_pose.position.y + dy * ratio\n            intermediate_pose.position.z = start_pose.position.z\n            intermediate_pose.orientation = start_pose.orientation\n\n            intermediate_poses.append(intermediate_pose)\n\n        return intermediate_poses\n\n    def generate_step_sequence(self, path):\n        """\n        Generate sequence of steps for humanoid execution\n        """\n        step_sequence = []\n        support_foot = "left"  # Start with left foot as support\n\n        for i in range(len(path) - 1):\n            current_pose = path[i]\n            target_pose = path[i + 1]\n\n            # Plan next step\n            next_step = self.step_planner.plan_next_step(current_pose, target_pose, support_foot)\n\n            # Add to sequence\n            step_sequence.append(next_step)\n\n            # Alternate support foot\n            support_foot = "right" if support_foot == "left" else "left"\n\n        return step_sequence\n'})}),"\n",(0,a.jsx)(n.h3,{id:"balance-monitoring-during-navigation",children:"Balance Monitoring During Navigation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Balance monitoring during navigation\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom std_msgs.msg import Bool\nimport tf2_ros\n\nclass BalanceMonitor(Node):\n    def __init__(self):\n        super().__init__('balance_monitor')\n\n        # Subscribers\n        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)\n        self.pose_sub = self.create_subscription(PoseStamped, '/robot_pose', self.pose_callback, 10)\n\n        # Publishers\n        self.balance_status_pub = self.create_publisher(Bool, '/balance_status', 10)\n        self.recovery_cmd_pub = self.create_publisher(Twist, '/recovery_command', 10)\n\n        # TF buffer for pose transformations\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n        # Balance assessment\n        self.balance_assessor = BalanceStabilityAssessment()\n        self.current_balance_state = None\n\n        # Timer for periodic balance checks\n        self.balance_timer = self.create_timer(0.1, self.balance_check_callback)  # 10Hz\n\n        # Parameters\n        self.declare_parameter('balance_threshold', 0.7)\n        self.declare_parameter('recovery_enabled', True)\n\n    def imu_callback(self, msg):\n        \"\"\"\n        Handle IMU data for balance assessment\n        \"\"\"\n        # Extract orientation from IMU\n        self.current_orientation = msg.orientation\n\n        # Extract angular velocity and linear acceleration\n        self.angular_velocity = msg.angular_velocity\n        self.linear_acceleration = msg.linear_acceleration\n\n    def pose_callback(self, msg):\n        \"\"\"\n        Handle pose updates\n        \"\"\"\n        self.current_pose = msg.pose\n\n    def balance_check_callback(self):\n        \"\"\"\n        Periodic balance check\n        \"\"\"\n        if self.current_pose is None or self.current_orientation is None:\n            return\n\n        # Create robot state for balance assessment\n        robot_state = {\n            'pose': self.current_pose,\n            'orientation': self.current_orientation,\n            'angular_velocity': self.angular_velocity,\n            'linear_acceleration': self.linear_acceleration\n        }\n\n        # Assess balance stability\n        stability_metrics = self.balance_assessor.assess_balance_stability(robot_state)\n\n        # Create balance status message\n        balance_msg = Bool()\n        balance_msg.data = stability_metrics['overall_stability'] > self.get_parameter('balance_threshold').value\n\n        # Publish balance status\n        self.balance_status_pub.publish(balance_msg)\n\n        # Check if recovery is needed\n        if not balance_msg.data and self.get_parameter('recovery_enabled').value:\n            self.initiate_balance_recovery()\n\n    def initiate_balance_recovery(self):\n        \"\"\"\n        Initiate balance recovery procedures\n        \"\"\"\n        self.get_logger().warn('Balance recovery initiated')\n\n        # Publish recovery command (e.g., stop movement, adjust posture)\n        recovery_cmd = Twist()\n        recovery_cmd.linear.x = 0.0\n        recovery_cmd.linear.y = 0.0\n        recovery_cmd.linear.z = 0.0\n        recovery_cmd.angular.x = 0.0\n        recovery_cmd.angular.y = 0.0\n        recovery_cmd.angular.z = 0.0\n\n        self.recovery_cmd_pub.publish(recovery_cmd)\n\n        # Could also trigger specific recovery behaviors here\n        self.trigger_recovery_behavior()\n\n    def trigger_recovery_behavior(self):\n        \"\"\"\n        Trigger specific recovery behavior\n        \"\"\"\n        # This could call a behavior tree recovery node\n        # or publish to a recovery action server\n        pass\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-execution-and-timing",children:"Step Execution and Timing"}),"\n",(0,a.jsx)(n.h3,{id:"step-execution-controller",children:"Step Execution Controller"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Step execution controller\nimport time\nfrom enum import Enum\n\nclass StepExecutionState(Enum):\n    IDLE = 1\n    LIFTING = 2\n    SWINGING = 3\n    PLACING = 4\n    STABILIZING = 5\n    COMPLETED = 6\n\nclass StepExecutionController:\n    def __init__(self):\n        self.state = StepExecutionState.IDLE\n        self.step_timing = 0.8  # seconds per step\n        self.lifting_phase_duration = 0.2\n        self.swinging_phase_duration = 0.4\n        self.placing_phase_duration = 0.15\n        self.stabilizing_phase_duration = 0.05\n\n        self.step_start_time = None\n        self.current_step_target = None\n\n    def execute_step(self, step_target):\n        """\n        Execute a single step to target position\n        """\n        self.current_step_target = step_target\n        self.state = StepExecutionState.LIFTING\n        self.step_start_time = time.time()\n\n        while self.state != StepExecutionState.COMPLETED:\n            current_time = time.time()\n            elapsed = current_time - self.step_start_time\n\n            if self.state == StepExecutionState.LIFTING:\n                if elapsed >= self.lifting_phase_duration:\n                    self.state = StepExecutionState.SWINGING\n                    self.step_start_time = current_time\n            elif self.state == StepExecutionState.SWINGING:\n                if elapsed >= self.swinging_phase_duration:\n                    self.state = StepExecutionState.PLACING\n                    self.step_start_time = current_time\n            elif self.state == StepExecutionState.PLACING:\n                if elapsed >= self.placing_phase_duration:\n                    self.state = StepExecutionState.STABILIZING\n                    self.step_start_time = current_time\n            elif self.state == StepExecutionState.STABILIZING:\n                if elapsed >= self.stabilizing_phase_duration:\n                    self.state = StepExecutionState.COMPLETED\n\n            # Execute phase-specific commands\n            self.execute_current_phase()\n\n    def execute_current_phase(self):\n        """\n        Execute commands for current phase\n        """\n        if self.state == StepExecutionState.LIFTING:\n            self.execute_lifting_phase()\n        elif self.state == StepExecutionState.SWINGING:\n            self.execute_swinging_phase()\n        elif self.state == StepExecutionState.PLACING:\n            self.execute_placing_phase()\n        elif self.state == StepExecutionState.STABILIZING:\n            self.execute_stabilizing_phase()\n\n    def execute_lifting_phase(self):\n        """\n        Execute lifting phase commands\n        """\n        # Lift foot to clearance height\n        pass\n\n    def execute_swinging_phase(self):\n        """\n        Execute swinging phase commands\n        """\n        # Swing foot to target position\n        pass\n\n    def execute_placing_phase(self):\n        """\n        Execute placing phase commands\n        """\n        # Place foot at target position\n        pass\n\n    def execute_stabilizing_phase(self):\n        """\n        Execute stabilizing phase commands\n        """\n        # Stabilize after step placement\n        pass\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"balance-and-performance-metrics",children:"Balance and Performance Metrics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Performance metrics for balance and step dynamics\nclass PerformanceMetrics:\n    def __init__(self):\n        self.metrics = {\n            \'balance_stability\': [],\n            \'step_accuracy\': [],\n            \'navigation_efficiency\': [],\n            \'recovery_frequency\': [],\n            \'computation_time\': []\n        }\n\n    def record_balance_stability(self, stability_score):\n        """\n        Record balance stability metric\n        """\n        self.metrics[\'balance_stability\'].append(stability_score)\n\n    def record_step_accuracy(self, target_pose, actual_pose):\n        """\n        Record step accuracy metric\n        """\n        error_distance = self.calculate_pose_error(target_pose, actual_pose)\n        self.metrics[\'step_accuracy\'].append(error_distance)\n\n    def record_navigation_efficiency(self, path_length, direct_distance):\n        """\n        Record navigation efficiency metric\n        """\n        efficiency = direct_distance / path_length if path_length > 0 else 0\n        self.metrics[\'navigation_efficiency\'].append(efficiency)\n\n    def record_recovery_event(self):\n        """\n        Record recovery event\n        """\n        self.metrics[\'recovery_frequency\'].append(time.time())\n\n    def record_computation_time(self, computation_time):\n        """\n        Record computation time\n        """\n        self.metrics[\'computation_time\'].append(computation_time)\n\n    def get_performance_summary(self):\n        """\n        Get performance summary\n        """\n        summary = {}\n        for metric_name, values in self.metrics.items():\n            if values:\n                if metric_name == \'recovery_frequency\':\n                    summary[metric_name] = len(values)  # Count events\n                else:\n                    summary[metric_name] = {\n                        \'mean\': sum(values) / len(values),\n                        \'min\': min(values),\n                        \'max\': max(values),\n                        \'count\': len(values)\n                    }\n            else:\n                summary[metric_name] = {\'mean\': 0, \'min\': 0, \'max\': 0, \'count\': 0}\n\n        return summary\n\n    def calculate_pose_error(self, target_pose, actual_pose):\n        """\n        Calculate error between target and actual poses\n        """\n        dx = target_pose.position.x - actual_pose.position.x\n        dy = target_pose.position.y - actual_pose.position.y\n        return math.sqrt(dx**2 + dy**2)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting-and-safety",children:"Troubleshooting and Safety"}),"\n",(0,a.jsx)(n.h3,{id:"common-balance-issues-and-solutions",children:"Common Balance Issues and Solutions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Troubleshooting guide for balance and step dynamics\ntroubleshooting:\n  common_issues:\n    - issue: "Balance loss during navigation"\n      symptoms:\n        - "Robot falls during movement"\n        - "Frequent balance recovery triggers"\n      causes:\n        - "Step size too large for current balance state"\n        - "Gait parameters not tuned for robot"\n        - "Terrain not properly classified"\n      solutions:\n        - "Reduce maximum step size"\n        - "Tune gait parameters for specific robot"\n        - "Improve terrain classification accuracy"\n        - "Add more conservative balance margins"\n\n    - issue: "Step execution failures"\n      symptoms:\n        - "Steps not completing properly"\n        - "Foot not reaching target position"\n      causes:\n        - "Timing parameters too aggressive"\n        - "Actuator limitations not considered"\n        - "Joint limit violations"\n      solutions:\n        - "Adjust timing parameters"\n        - "Consider actuator capabilities"\n        - "Implement joint limit checking"\n\n    - issue: "Inefficient navigation paths"\n      symptoms:\n        - "Long navigation times"\n        - "Excessive steps for simple paths"\n      causes:\n        - "Overly conservative balance constraints"\n        - "Poor path optimization"\n        - "Inadequate step planning"\n      solutions:\n        - "Tune balance constraints appropriately"\n        - "Improve path planning algorithms"\n        - "Optimize step planning for efficiency"\n\n    - issue: "Recovery behavior loops"\n      symptoms:\n        - "Robot stuck in recovery mode"\n        - "Continuous balance recovery attempts"\n      causes:\n        - "Recovery behavior not properly terminating"\n        - "Underlying balance issue not resolved"\n        - "Environment too challenging"\n      solutions:\n        - "Implement proper recovery termination conditions"\n        - "Add alternative navigation strategies"\n        - "Improve environment assessment"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Emergency Stop"}),": Implement immediate stop capability when balance is critically compromised"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Recovery Behaviors"}),": Design safe recovery behaviors that don't worsen the situation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Terrain Assessment"}),": Properly assess terrain before attempting navigation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Validation"}),": Validate each step before execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitoring"}),": Continuous monitoring of balance metrics during navigation"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"design-guidelines",children:"Design Guidelines"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Conservative Approach"}),": Start with conservative balance parameters and gradually expand"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Modular Design"}),": Separate balance checking, step planning, and execution logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real-time Capability"}),": Ensure all balance calculations can run in real-time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simulation Testing"}),": Extensively test in simulation before real robot deployment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Progressive Complexity"}),": Start with simple navigation tasks and increase complexity gradually"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State Machines"}),": Use state machines for step execution to handle different phases"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Tuning"}),": Carefully tune parameters for your specific robot model"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logging"}),": Implement comprehensive logging for debugging balance issues"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fallback Systems"}),": Always have fallback behaviors when balance is compromised"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation"}),": Continuously validate balance throughout the navigation process"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This comprehensive guide covers the essential concepts and implementations for managing balance and step dynamics in humanoid robot navigation using Nav2."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);