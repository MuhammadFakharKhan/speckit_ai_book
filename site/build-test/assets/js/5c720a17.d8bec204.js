"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[3233],{3023(e,n,a){a.d(n,{R:()=>t,x:()=>o});var i=a(3696);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},7886(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=a(2540),s=a(3023);const r={title:"ROS 2 Integration",description:"Integrating Isaac ROS perception pipelines with ROS 2 for humanoid robotics applications",sidebar_position:4,tags:["ros2","integration","isaac-ros","perception","middleware"]},t="ROS 2 Integration",o={id:"isaac-ros/ros2-integration",title:"ROS 2 Integration",description:"Integrating Isaac ROS perception pipelines with ROS 2 for humanoid robotics applications",source:"@site/docs/isaac-ros/ros2-integration.md",sourceDirName:"isaac-ros",slug:"/isaac-ros/ros2-integration",permalink:"/docs/isaac-ros/ros2-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-ros/ros2-integration.md",tags:[{label:"ros2",permalink:"/docs/tags/ros-2"},{label:"integration",permalink:"/docs/tags/integration"},{label:"isaac-ros",permalink:"/docs/tags/isaac-ros"},{label:"perception",permalink:"/docs/tags/perception"},{label:"middleware",permalink:"/docs/tags/middleware"}],version:"current",sidebarPosition:4,frontMatter:{title:"ROS 2 Integration",description:"Integrating Isaac ROS perception pipelines with ROS 2 for humanoid robotics applications",sidebar_position:4,tags:["ros2","integration","isaac-ros","perception","middleware"]},sidebar:"tutorialSidebar",previous:{title:"Perception Pipeline Configurations",permalink:"/docs/isaac-ros/perception-pipeline-configurations"},next:{title:"Sensor Processing with GPU Acceleration",permalink:"/docs/isaac-ros/sensor-processing-gpu-acceleration"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Isaac ROS in the ROS 2 Ecosystem",id:"isaac-ros-in-the-ros-2-ecosystem",level:2},{value:"Package Structure",id:"package-structure",level:3},{value:"Message Types and Interfaces",id:"message-types-and-interfaces",level:3},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Installation Process",id:"installation-process",level:3},{value:"Verification",id:"verification",level:3},{value:"Node Configuration and Launch",id:"node-configuration-and-launch",level:2},{value:"Launch Files",id:"launch-files",level:3},{value:"Configuration Files",id:"configuration-files",level:3},{value:"Integration with ROS 2 Ecosystem",id:"integration-with-ros-2-ecosystem",level:2},{value:"TF (Transform) Integration",id:"tf-transform-integration",level:3},{value:"Parameter Management",id:"parameter-management",level:3},{value:"Hardware Acceleration Configuration",id:"hardware-acceleration-configuration",level:2},{value:"GPU Selection and Management",id:"gpu-selection-and-management",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Integration with Other ROS 2 Packages",id:"integration-with-other-ros-2-packages",level:2},{value:"Navigation Integration",id:"navigation-integration",level:3},{value:"Perception Pipeline Integration",id:"perception-pipeline-integration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Communication Optimization",id:"communication-optimization",level:3},{value:"Pipeline Synchronization",id:"pipeline-synchronization",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Integration Issues",id:"common-integration-issues",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Architecture Design",id:"architecture-design",level:3},{value:"Development Workflow",id:"development-workflow",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Isaac ROS is designed for seamless integration with ROS 2, providing hardware-accelerated perception capabilities that fit naturally into the ROS 2 ecosystem. This integration is essential for humanoid robotics applications that require real-time perception within the broader ROS 2 framework."}),"\n",(0,i.jsx)(n.h2,{id:"isaac-ros-in-the-ros-2-ecosystem",children:"Isaac ROS in the ROS 2 Ecosystem"}),"\n",(0,i.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,i.jsx)(n.p,{children:"Isaac ROS follows ROS 2 conventions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Standard interfaces"}),": Uses ROS 2 message types and services"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node structure"}),": Organized as standard ROS 2 nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter system"}),": Leverages ROS 2 parameter system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Launch system"}),": Compatible with ROS 2 launch system"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"message-types-and-interfaces",children:"Message Types and Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"Isaac ROS uses standard ROS 2 message types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"sensor_msgs"}),": For sensor data (images, point clouds, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"geometry_msgs"}),": For poses, transforms, and vectors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"nav_msgs"}),": For navigation-related messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"custom messages"}),": Specialized types for Isaac ROS features"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,i.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before using Isaac ROS with ROS 2:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 installation"}),": Properly installed ROS 2 distribution (Humble Hawksbill or later)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"NVIDIA GPU"}),": Compatible GPU with appropriate drivers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CUDA toolkit"}),": Installed CUDA development tools"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Isaac ROS packages"}),": Correct versions for your ROS distribution"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"installation-process",children:"Installation Process"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Update package lists\nsudo apt update\n\n# Install Isaac ROS core packages\nsudo apt install ros-humble-isaac-ros-core\n\n# Install specific perception packages\nsudo apt install ros-humble-isaac-ros-perception\nsudo apt install ros-humble-isaac-ros-visual-slam\n\n# Install additional packages as needed\nsudo apt install ros-humble-isaac-ros-*\n"})}),"\n",(0,i.jsx)(n.h3,{id:"verification",children:"Verification"}),"\n",(0,i.jsx)(n.p,{children:"Verify the installation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check available Isaac ROS packages\nros2 pkg list | grep isaac_ros\n\n# Source the ROS environment\nsource /opt/ros/humble/setup.bash\n\n# Test basic functionality\nros2 run isaac_ros_test test_nodes\n"})}),"\n",(0,i.jsx)(n.h2,{id:"node-configuration-and-launch",children:"Node Configuration and Launch"}),"\n",(0,i.jsx)(n.h3,{id:"launch-files",children:"Launch Files"}),"\n",(0,i.jsx)(n.p,{children:"Create launch files for Isaac ROS nodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example launch file for Isaac ROS perception pipeline\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    config_dir = os.path.join(\n        get_package_share_directory('my_robot_config'),\n        'config'\n    )\n\n    return LaunchDescription([\n        # Isaac ROS image pipeline node\n        Node(\n            package='isaac_ros_image_pipeline',\n            executable='isaac_ros_image_rectification',\n            name='image_rectification',\n            parameters=[\n                os.path.join(config_dir, 'image_rectification.yaml')\n            ],\n            remappings=[\n                ('image_raw', '/camera/image_raw'),\n                ('image_rect', '/camera/image_rect'),\n                ('camera_info', '/camera/camera_info')\n            ]\n        ),\n\n        # Isaac ROS VSLAM node\n        Node(\n            package='isaac_ros_visual_slam',\n            executable='isaac_ros_visual_slam_node',\n            name='visual_slam',\n            parameters=[\n                os.path.join(config_dir, 'visual_slam.yaml')\n            ],\n            remappings=[\n                ('/visual_slam/image', '/camera/image_rect'),\n                ('/visual_slam/camera_info', '/camera/camera_info'),\n                ('/visual_slam/pose', '/vslam/pose')\n            ]\n        )\n    ])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"configuration-files",children:"Configuration Files"}),"\n",(0,i.jsx)(n.p,{children:"Configure Isaac ROS nodes using YAML files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Example configuration for Isaac ROS VSLAM\nvisual_slam:\n  ros__parameters:\n    # Camera parameters\n    image_width: 1280\n    image_height: 720\n\n    # Feature parameters\n    max_num_features: 1000\n    min_feature_distance: 20\n\n    # Tracking parameters\n    max_features: 500\n    tracking_quality_threshold: 20\n\n    # Mapping parameters\n    map_size: 100\n    enable_localization: true\n\n    # GPU acceleration\n    use_gpu: true\n    gpu_id: 0\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-ros-2-ecosystem",children:"Integration with ROS 2 Ecosystem"}),"\n",(0,i.jsx)(n.h3,{id:"tf-transform-integration",children:"TF (Transform) Integration"}),"\n",(0,i.jsx)(n.p,{children:"Isaac ROS integrates with ROS 2's transform system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example TF broadcasting from Isaac ROS node\nimport rclpy\nfrom rclpy.node import Node\nfrom tf2_ros import TransformBroadcaster\nfrom geometry_msgs.msg import TransformStamped\n\nclass IsaacROSTFNode(Node):\n    def __init__(self):\n        super().__init__('isaac_ros_tf_node')\n\n        # Initialize TF broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Subscribe to pose estimates from Isaac ROS\n        self.pose_sub = self.create_subscription(\n            Pose,\n            '/vslam/pose',\n            self.pose_callback,\n            10\n        )\n\n    def pose_callback(self, msg):\n        # Create transform from pose\n        t = TransformStamped()\n\n        t.header.stamp = self.get_clock().now().to_msg()\n        t.header.frame_id = 'map'\n        t.child_frame_id = 'base_link'\n\n        t.transform.translation.x = msg.position.x\n        t.transform.translation.y = msg.position.y\n        t.transform.translation.z = msg.position.z\n        t.transform.rotation = msg.orientation\n\n        # Broadcast transform\n        self.tf_broadcaster.sendTransform(t)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-management",children:"Parameter Management"}),"\n",(0,i.jsx)(n.p,{children:"Use ROS 2 parameter system for configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example parameter management in Isaac ROS node\nfrom rclpy.parameter import Parameter\nfrom rclpy.node import Node\n\nclass IsaacROSParameterNode(Node):\n    def __init__(self):\n        super().__init__('isaac_ros_param_node')\n\n        # Declare parameters with defaults\n        self.declare_parameter('max_features', 1000)\n        self.declare_parameter('min_feature_distance', 20)\n        self.declare_parameter('use_gpu', True)\n\n        # Get parameter values\n        self.max_features = self.get_parameter('max_features').value\n        self.min_feature_distance = self.get_parameter('min_feature_distance').value\n        self.use_gpu = self.get_parameter('use_gpu').value\n\n        # Set up parameter callback for dynamic reconfiguration\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'max_features':\n                # Update internal configuration\n                self.max_features = param.value\n            elif param.name == 'min_feature_distance':\n                self.min_feature_distance = param.value\n        return SetParametersResult(successful=True)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hardware-acceleration-configuration",children:"Hardware Acceleration Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"gpu-selection-and-management",children:"GPU Selection and Management"}),"\n",(0,i.jsx)(n.p,{children:"Configure GPU usage in Isaac ROS:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example GPU configuration\nimport cuda\nimport rclpy\n\nclass IsaacROSGPUConfigNode(Node):\n    def __init__(self):\n        super().__init__('isaac_ros_gpu_config')\n\n        # Get available GPUs\n        gpu_count = cuda.cudaGetDeviceCount()\n        self.get_logger().info(f'Available GPUs: {gpu_count}')\n\n        # Configure GPU selection\n        self.declare_parameter('gpu_id', 0)\n        self.gpu_id = self.get_parameter('gpu_id').value\n\n        # Set GPU device\n        cuda.cudaSetDevice(self.gpu_id)\n\n        # Configure Isaac ROS with GPU\n        self.configure_isaac_ros_gpu()\n\n    def configure_isaac_ros_gpu(self):\n        # Configure Isaac ROS components for GPU usage\n        # Implementation depends on specific Isaac ROS package\n        pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(n.p,{children:"Handle GPU memory efficiently:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example GPU memory management\nclass IsaacROSMemoryManager:\n    def __init__(self):\n        self.gpu_memory_pool = None\n        self.current_memory_usage = 0\n        self.max_memory = self.get_gpu_memory_limit()\n\n    def get_gpu_memory_limit(self):\n        # Get available GPU memory\n        # Implementation specific to GPU library\n        pass\n\n    def allocate_memory(self, size):\n        if self.current_memory_usage + size > self.max_memory:\n            self.cleanup_memory()\n\n        # Allocate GPU memory\n        memory_ptr = cuda_malloc(size)\n        self.current_memory_usage += size\n\n        return memory_ptr\n\n    def cleanup_memory(self):\n        # Release unused GPU memory\n        # Implementation specific to memory management strategy\n        pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-other-ros-2-packages",children:"Integration with Other ROS 2 Packages"}),"\n",(0,i.jsx)(n.h3,{id:"navigation-integration",children:"Navigation Integration"}),"\n",(0,i.jsx)(n.p,{children:"Connect Isaac ROS perception with ROS 2 Navigation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example integration with Nav2\nclass IsaacROSNav2Interface:\n    def __init__(self):\n        # Initialize Isaac ROS VSLAM\n        self.vslam_node = IsaacROSVSLAMNode()\n\n        # Initialize Nav2 interface\n        self.nav2_client = NavigationActionClient()\n\n        # Subscribe to VSLAM pose estimates\n        self.vslam_node.pose_sub.add_callback(\n            self.on_pose_update\n        )\n\n    def on_pose_update(self, pose_msg):\n        # Update Nav2 with current pose\n        self.nav2_client.update_current_pose(pose_msg)\n\n        # Check navigation readiness\n        if self.is_navigation_ready():\n            self.nav2_client.enable_navigation()\n\n    def is_navigation_ready(self):\n        # Check if localization is confident\n        # Implementation depends on specific requirements\n        return True\n"})}),"\n",(0,i.jsx)(n.h3,{id:"perception-pipeline-integration",children:"Perception Pipeline Integration"}),"\n",(0,i.jsx)(n.p,{children:"Integrate with ROS 2 perception stack:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example perception pipeline integration\nclass IsaacROSPipelineIntegration:\n    def __init__(self):\n        # Isaac ROS perception nodes\n        self.image_pipeline = IsaacROSImagePipeline()\n        self.feature_detector = IsaacROSFeatureDetector()\n        self.object_detector = IsaacROSObjectDetector()\n\n        # Standard ROS 2 perception nodes\n        self.segmentation_node = ROS2SegmentationNode()\n        self.tracking_node = ROS2TrackingNode()\n\n    def process_sensor_data(self, sensor_msg):\n        # Process through Isaac ROS pipeline\n        accelerated_features = self.feature_detector.detect(sensor_msg)\n        objects = self.object_detector.detect(sensor_msg)\n\n        # Pass results to ROS 2 perception stack\n        self.segmentation_node.process_features(accelerated_features)\n        self.tracking_node.process_objects(objects)\n\n        return {\n            'features': accelerated_features,\n            'objects': objects,\n            'segmentation': self.segmentation_node.get_result(),\n            'tracking': self.tracking_node.get_result()\n        }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"communication-optimization",children:"Communication Optimization"}),"\n",(0,i.jsx)(n.p,{children:"Optimize ROS 2 communication for Isaac ROS:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example communication optimization\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\nclass IsaacROSCommunicationOptimizer:\n    def __init__(self):\n        # Create optimized QoS profiles\n        self.image_qos = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=1  # Keep only latest image for real-time processing\n        )\n\n        self.pose_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_ALL,\n            depth=100  # Keep pose history for trajectory\n        )\n\n    def create_optimized_subscriber(self, msg_type, topic, callback):\n        return self.create_subscription(\n            msg_type, topic, callback, self.image_qos\n        )\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pipeline-synchronization",children:"Pipeline Synchronization"}),"\n",(0,i.jsx)(n.p,{children:"Synchronize Isaac ROS pipeline with ROS 2 timing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example pipeline synchronization\nfrom rclpy.time import Time\nfrom builtin_interfaces.msg import Time as TimeMsg\n\nclass IsaacROSPipelineSynchronizer:\n    def __init__(self):\n        self.message_queue = {}\n        self.sync_window = 0.1  # 100ms sync window\n\n    def queue_message(self, topic, msg):\n        timestamp = Time.from_msg(msg.header.stamp)\n        if topic not in self.message_queue:\n            self.message_queue[topic] = []\n\n        self.message_queue[topic].append((timestamp, msg))\n        self.attempt_sync()\n\n    def attempt_sync(self):\n        # Try to synchronize messages from different topics\n        # Implementation depends on specific synchronization requirements\n        pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"common-integration-issues",children:"Common Integration Issues"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message type mismatches"}),": Ensure Isaac ROS and ROS 2 message types are compatible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timing issues"}),": Handle different processing rates between nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TF frame mismatches"}),": Ensure consistent frame naming and conventions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GPU resource conflicts"}),": Manage GPU resources across multiple nodes"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,i.jsx)(n.p,{children:"Monitor integration performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Monitor ROS 2 topics and message rates\nros2 topic echo /vslam/pose --field header.stamp\n\n# Check TF tree\nros2 run tf2_tools view_frames\n\n# Monitor node performance\nros2 run isaac_ros_test performance_monitor\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"architecture-design",children:"Architecture Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modular design"}),": Keep Isaac ROS components modular and replaceable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration management"}),": Use ROS 2 parameters for all configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error handling"}),": Implement robust error handling for hardware failures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource management"}),": Properly manage GPU and system resources"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"development-workflow",children:"Development Workflow"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation first"}),": Test integration in simulation before hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incremental integration"}),": Add Isaac ROS components gradually"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Validate results against standard ROS 2 alternatives"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Document all integration points and configurations"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.p,{children:["For more detailed information about Isaac ROS integration with ROS 2, refer to the ",(0,i.jsx)(n.a,{href:"https://isaac-ros.github.io/",children:"official Isaac ROS documentation"})," and the ",(0,i.jsx)(n.a,{href:"https://docs.ros.org/",children:"ROS 2 documentation"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);